{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/Tornadokuangjia.png","path":"img/Tornadokuangjia.png","modified":1,"renderable":0},{"_id":"source/img/proxy.jpg","path":"img/proxy.jpg","modified":1,"renderable":0},{"_id":"source/img/wangluocengci.png","path":"img/wangluocengci.png","modified":1,"renderable":0},{"_id":"themes/artemis/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/artemis/source/logo-alt.png","path":"logo-alt.png","modified":1,"renderable":1},{"_id":"themes/artemis/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/artemis/source/css/theme.css","path":"css/theme.css","modified":1,"renderable":1},{"_id":"themes/artemis/source/css/theme.css.map","path":"css/theme.css.map","modified":1,"renderable":1},{"_id":"themes/artemis/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1,"renderable":1},{"_id":"themes/artemis/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1,"renderable":1},{"_id":"themes/artemis/source/scss/theme.scss","path":"scss/theme.scss","modified":1,"renderable":1},{"_id":"source/img/zhengfanxiang.png","path":"img/zhengfanxiang.png","modified":1,"renderable":0},{"_id":"themes/artemis/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/artemis/source/font/fontawesome-webfont.woff2","path":"font/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/artemis/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/artemis/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/artemis/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/artemis/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"edf90a40cb09b9987f519255b6d2cdd3b023fb05","modified":1523152849637},{"_id":"source/_drafts/支付的基本概念.md","hash":"4174e545e3f6276a3441eed50964b56ef23ed9b0","modified":1523180757477},{"_id":"source/_drafts/支付相关政策学习.md","hash":"9052ea87a771f419684d90cdb3aca16758696c9a","modified":1523181467628},{"_id":"source/_drafts/金融机构基本知识.md","hash":"e648f28634d90837b2512a99a8cb7eaeddb4454d","modified":1523180190338},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1523181478925},{"_id":"source/_posts/.DS_Store","hash":"cf145a60e0ff73f0f3d97261773112d0660e8bc3","modified":1522405740834},{"_id":"source/_posts/Tornadoweb学习笔记.md","hash":"4f1631ecc2cef4b2fe1a5ab195e51277630ff1ea","modified":1522398738544},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1520840587737},{"_id":"source/_posts/linux学习笔记.md","hash":"33be6c9fb007e71e44740d6d0d156e068133869d","modified":1521705052634},{"_id":"source/_posts/pug和hexo学习笔记.md","hash":"c28b2b701ec867eccf28b4b11b570874ea95b78d","modified":1522290754452},{"_id":"source/_posts/python-面向对象技术.md","hash":"c17854979eb66d9672efd4f2d5e95d37ec00e1aa","modified":1522395825460},{"_id":"source/_posts/python变量.md","hash":"8f07d9ee3d25c101567ce96c801c41c299100fe1","modified":1522296995953},{"_id":"source/_posts/python学习笔记.md","hash":"a09610c8f5fd3e4b054534e6305689756d43057f","modified":1522383741934},{"_id":"source/_posts/后端学习笔记.md","hash":"fe5fed3c6d368931d266ab9031ecce7c49bf2df8","modified":1522293348769},{"_id":"source/_posts/前端学习笔记.md","hash":"6146e041fd03fa9a008c1a56070c1d1ea9367416","modified":1522290775448},{"_id":"source/_posts/python异常处理.md","hash":"4647b5909e2ff297f3162d2ccf5225f075d6e5f9","modified":1522381279746},{"_id":"source/_posts/网络技术学习笔记.md","hash":"8cba4b7e150c90ae7d839f81da08294de87143a7","modified":1521603346561},{"_id":"source/_posts/股票学习笔记.md","hash":"2d3f1fac38e31e1c7c7907b39f1b32a4f6dc7936","modified":1522222784600},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1522123937960},{"_id":"source/categories/index.md","hash":"b2ef766b74a11ae925a66f689577b04157c416c6","modified":1522123868562},{"_id":"source/img/.DS_Store","hash":"8935e75f6651d2c992406a91ccdb5a806f29f685","modified":1521455667371},{"_id":"source/img/Tornadokuangjia.png","hash":"d75e438b75fefc45545c6b25b84ecd3ee229242d","modified":1521514486666},{"_id":"source/img/proxy.jpg","hash":"26a6e560afc240e8a4b998a3a3d68f7da267673f","modified":1521451606202},{"_id":"source/img/wangluocengci.png","hash":"05b1a86f6f5edf4298a5bdcb9ed5e7e4daa4522a","modified":1521540055761},{"_id":"source/tags/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1522052583760},{"_id":"source/tags/index.md","hash":"8650a477cba3c2d99713859d4d696ba1fa2ee8ab","modified":1522222741253},{"_id":"themes/artemis/.DS_Store","hash":"f7ae313bb5efdee41de033fa116b8a7749ce589b","modified":1523156003646},{"_id":"themes/artemis/.gitignore","hash":"6647c561b3b92dbbb8fed18d267598def2175068","modified":1521010345405},{"_id":"themes/artemis/Gruntfile.js","hash":"1fac3ef7b4b0be6e3645de1b6eb386f7b316583b","modified":1521010345405},{"_id":"themes/artemis/LICENSE","hash":"dc82fac932c3bcc2f71c42e6b60844b56e29ea1e","modified":1521010345406},{"_id":"themes/artemis/README.md","hash":"5ccf5fa7bbc5d241a6a093850f38a4a55f19b3e5","modified":1521010345406},{"_id":"themes/artemis/_config.yml","hash":"1428575f947c6323ffd8e368aaf13f5528271879","modified":1522042645489},{"_id":"themes/artemis/package.json","hash":"7a58158a8d9ea9b9a7b595ff49ed5c440ea76aaa","modified":1521010345412},{"_id":"themes/artemis/screenshot.png","hash":"65565ef169c633e62d2735961fa8dbe8c47a6ffb","modified":1521010345413},{"_id":"themes/artemis/layout/about.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521015220466},{"_id":"themes/artemis/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1521010345396},{"_id":"themes/artemis/.git/config","hash":"258fd8d6ba88e10c1a6ffb1636682e669ee850cc","modified":1521010345399},{"_id":"themes/artemis/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1521010340820},{"_id":"themes/artemis/.git/index","hash":"dc1978f5e41c38e5401342f49e864aa75b785a05","modified":1522231715957},{"_id":"themes/artemis/.git/packed-refs","hash":"a7a3108cf51ddd592c1512fb465da91c2b9af1eb","modified":1521010345393},{"_id":"themes/artemis/.idea/hexo-theme-artemis.iml","hash":"4240dabdc746a36bae8a56eeec04a3a3fc59d842","modified":1521010435775},{"_id":"themes/artemis/.idea/modules.xml","hash":"7ca6b34b4b8c8b5bfe6b606e2fbb4b6bafa9b8b0","modified":1521010435789},{"_id":"themes/artemis/.idea/vcs.xml","hash":"c92f3eb0ad1c70371e177a4d7d741f90af3f902c","modified":1521010456923},{"_id":"themes/artemis/.idea/workspace.xml","hash":"c2cf47df958d8bf4f53c24204a8cb8c267ac7a23","modified":1522320344163},{"_id":"themes/artemis/languages/en.yml","hash":"678bad7e2e314c49bd4b78b0229839315c7f1415","modified":1521010345407},{"_id":"themes/artemis/layout/.DS_Store","hash":"1a79b16429be7d487fef606a5c8ddae132864c10","modified":1523156142286},{"_id":"themes/artemis/layout/archive.pug","hash":"86aa3e23c4fb1ae2633c315bf6901fd2ed95be8f","modified":1521010345407},{"_id":"themes/artemis/layout/index.pug","hash":"52fd4433e7b170c0ed9813173714d55e7d5fa016","modified":1521010345408},{"_id":"themes/artemis/layout/post.pug","hash":"315e5bee4b085c3c998876bfb3cbd093f89e7d79","modified":1522141675895},{"_id":"themes/artemis/layout/tag.pug","hash":"fb3ee77e3e607538a533fbac77937112fd9e2fde","modified":1522231235535},{"_id":"themes/artemis/layout/tags.pug","hash":"d19a794b9e7469ae9f4a9da55f0cfe31c24ba4a6","modified":1522230686593},{"_id":"themes/artemis/source/.DS_Store","hash":"31ce5a44c569784d892efb98f8ee9a25d5c22205","modified":1522293298738},{"_id":"themes/artemis/source/favicon.png","hash":"388bc1ee7d189af29cb7cc02b47fe0aba0922d27","modified":1521010345414},{"_id":"themes/artemis/source/logo-alt.png","hash":"b3027419b010a576d26d2531470c189566fa94cf","modified":1521010345415},{"_id":"themes/artemis/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1521010340819},{"_id":"themes/artemis/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1521010340821},{"_id":"themes/artemis/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1521010340820},{"_id":"themes/artemis/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1521010340822},{"_id":"themes/artemis/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1521010340822},{"_id":"themes/artemis/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1521010340820},{"_id":"themes/artemis/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1521010340822},{"_id":"themes/artemis/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1521010340820},{"_id":"themes/artemis/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1521010340821},{"_id":"themes/artemis/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1521010340821},{"_id":"themes/artemis/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1521010340822},{"_id":"themes/artemis/.git/logs/HEAD","hash":"fc3c4cca819922e6c3d289b89c438f8410f946e2","modified":1521010345397},{"_id":"themes/artemis/layout/mixins/paginator.pug","hash":"4bf911d0e391ed1ef35673fc87b1293f7d07e850","modified":1521010345408},{"_id":"themes/artemis/layout/mixins/post.pug","hash":"d408cff2a961d109e003bb707afdcc101e898740","modified":1522231298255},{"_id":"themes/artemis/layout/partial/comment.pug","hash":"4699ea58f7cdc1743e0627edc0359f415dcded30","modified":1521010345409},{"_id":"themes/artemis/layout/partial/copyright.pug","hash":"19cebf3ff5545319dda3d75dfa9ff069ec36c97d","modified":1521010345409},{"_id":"themes/artemis/layout/partial/head.pug","hash":"fe3938abc7a62fe328cad76ad231b0d2ad985804","modified":1522135783291},{"_id":"themes/artemis/layout/partial/layout.pug","hash":"76bf9a699d33ccd42dd3af389573767a24bfc11f","modified":1522121606007},{"_id":"themes/artemis/layout/partial/nav.pug","hash":"78da825d72ba8c6c1c5cd6e9ee8d847618d9a464","modified":1522118544561},{"_id":"themes/artemis/layout/partial/scripts.pug","hash":"e7041a8a82c654df5ed0b3d94da627927e1f7377","modified":1523156244462},{"_id":"themes/artemis/source/css/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1522231516646},{"_id":"themes/artemis/source/css/font-awesome.min.css","hash":"9143ba2c562d06379e2799119505a7ec80ea0801","modified":1522135251110},{"_id":"themes/artemis/source/css/theme.css","hash":"f89e7064d91f13fcfce67307f2e86d1bee4a414f","modified":1522226144334},{"_id":"themes/artemis/source/css/theme.css.map","hash":"d5a1d9cb4113d86df43fbec56391690b906c5024","modified":1522226144632},{"_id":"themes/artemis/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1521010345414},{"_id":"themes/artemis/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1521010345415},{"_id":"themes/artemis/source/scss/.DS_Store","hash":"be62a2356c9cc4fdb29d8d26fef1042e49ed85e6","modified":1522232244875},{"_id":"themes/artemis/source/scss/theme.scss","hash":"49938a4385074b8a87bd65fcdc167b3563c77115","modified":1522225693153},{"_id":"source/img/zhengfanxiang.png","hash":"6e04799cb1c4b13e974ca370bfb6a0d241d6aa47","modified":1521455526846},{"_id":"themes/artemis/source/font/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1477558304000},{"_id":"themes/artemis/source/font/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1477558304000},{"_id":"themes/artemis/.git/objects/pack/pack-23b37a18e9c3a451546a952f3c85a6f21658df23.idx","hash":"de9a8c46eafa93daec4d5c2cf841e82b1c23a875","modified":1521010345376},{"_id":"themes/artemis/.git/refs/heads/master","hash":"ff2c7769790a5ddcc5c34963f9ae1c61923d2d0e","modified":1521010345397},{"_id":"themes/artemis/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391","hash":"c2baae88d6364d878fd67e778c6a5d8306ad4ab0","modified":1522225591000},{"_id":"themes/artemis/source/font/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1477558304000},{"_id":"themes/artemis/source/font/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1477558304000},{"_id":"themes/artemis/source/font/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1477558304000},{"_id":"themes/artemis/source/scss/_partial/archive-post-list.scss","hash":"dd71a10b5558838436e88cc253d0fe2e62d343e5","modified":1521010345416},{"_id":"themes/artemis/source/scss/_partial/base.scss","hash":"9cd674eff7c878a5e903be21cc303411fa237582","modified":1521010345416},{"_id":"themes/artemis/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1521010345417},{"_id":"themes/artemis/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1521010345417},{"_id":"themes/artemis/source/scss/_partial/header.scss","hash":"6e0ba1875ac2ccaa491260da0e2975a8adfed671","modified":1521444062684},{"_id":"themes/artemis/source/scss/_partial/highlight.scss","hash":"94fd5b64c8ed921a9978fb97689279c0d8d9d122","modified":1521010345418},{"_id":"themes/artemis/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1521010345418},{"_id":"themes/artemis/source/scss/_partial/mq.scss","hash":"a980273256269ca15dfd7cc3333b35db72bb595f","modified":1521010345419},{"_id":"themes/artemis/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1521010345419},{"_id":"themes/artemis/source/scss/_partial/post.scss","hash":"d9076bcd52bd4fc176f44052934d441065bf0fd6","modified":1522225693166},{"_id":"themes/artemis/source/scss/_partial/tag.scss","hash":"f64bc4c7ee37e56748ee0290cd2bbc68bb087ddc","modified":1522225693162},{"_id":"themes/artemis/.git/objects/pack/pack-23b37a18e9c3a451546a952f3c85a6f21658df23.pack","hash":"b776906bb47318eff639b20aa7bed924519cf7ce","modified":1521010345376},{"_id":"themes/artemis/.git/logs/refs/heads/master","hash":"fc3c4cca819922e6c3d289b89c438f8410f946e2","modified":1521010345398},{"_id":"themes/artemis/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1521010345396},{"_id":"themes/artemis/.git/logs/refs/remotes/origin/HEAD","hash":"fc3c4cca819922e6c3d289b89c438f8410f946e2","modified":1521010345395},{"_id":"themes/artemis/source/font/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1477558304000}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2018-03-27T04:11:08.000Z","type":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-03-27 12:11:08\ntype:\n---\n","updated":"2018-03-27T04:11:08.562Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjfqmxgmx001r1yoh7tiktk0s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-03-26T08:22:10.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-03-26 16:22:10\nlayout: tags\n---\n","updated":"2018-03-28T07:39:01.253Z","path":"tags/index.html","comments":1,"_id":"cjfqmxgmz001s1yohfbhf9r7s","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"支付的基本概念","_content":"\n## 支付的本质\n支付产生于交易，交易的存在是支付发生的前提。\n*****\n\n## 支付的基本模型\n\n#### 买卖交易类型：\n```mermaid\n\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    买家-->>卖家:进行支付，清偿债权和债务关系\n    deactivate 买家\n    deactivate 卖家\n\n```\n\n在这个交易过程中：\n* 商品从卖家转移到买家，完成商品所有权的转移，形成债权和债务关系；\n* 买家通过现金或其它方式完成支付，清偿此债务，交易过程完成。\n*****\n#### 基于商业信用的交易类型：\n当卖家和买家建立了牢固的信用关系后，可基于信用进行交易。这种信用称为商业信用，其基本形式是赊销商品和预付货款。\n\n```mermaid\n\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    deactivate 买家\n    deactivate 卖家\n    买家-->>卖家:延期或分期进行支付，清偿债权和债务关系\n    activate 买家\n    activate 卖家\n    deactivate 买家\n    deactivate 卖家\n\n```\n\n特点：\n* 商业信用提供的对象是企业再生产总资本的一部分。\n* 企业为了使再生产连续进行，不能长期将资本借出，商业信用一般只适用于短期借贷。\n\n\n*****\n#### 基于银行信用的交易类型：\n银行信用是银行和各类金融机构以货币形式提供的信用。银行信用是在商业信用基础上产生和发展起来的。\n\n```mermaid\n\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    participant 银行\n    买家->>银行:进行借款，形成债权和债务关系\n    activate 买家\n    activate 银行\n    deactivate 买家\n    deactivate 银行\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    买家->>卖家:进行支付，清偿债权和债务关系\n    deactivate 买家\n    deactivate 卖家\n    银行->>买家:收回借款，清偿债权和债务关系\n    activate 买家\n    activate 银行\n    deactivate 银行\n    deactivate 银行\n\n```\n\n## 支付结算概念\n是指单位、个人在社会经济活动中进行货币给付及资金清算的行为。\n\n\n\n\n","source":"_drafts/支付的基本概念.md","raw":"---\ntitle: 支付的基本概念\ntags:\n   - 产品\n   - 支付\n---\n\n## 支付的本质\n支付产生于交易，交易的存在是支付发生的前提。\n*****\n\n## 支付的基本模型\n\n#### 买卖交易类型：\n```mermaid\n\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    买家-->>卖家:进行支付，清偿债权和债务关系\n    deactivate 买家\n    deactivate 卖家\n\n```\n\n在这个交易过程中：\n* 商品从卖家转移到买家，完成商品所有权的转移，形成债权和债务关系；\n* 买家通过现金或其它方式完成支付，清偿此债务，交易过程完成。\n*****\n#### 基于商业信用的交易类型：\n当卖家和买家建立了牢固的信用关系后，可基于信用进行交易。这种信用称为商业信用，其基本形式是赊销商品和预付货款。\n\n```mermaid\n\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    deactivate 买家\n    deactivate 卖家\n    买家-->>卖家:延期或分期进行支付，清偿债权和债务关系\n    activate 买家\n    activate 卖家\n    deactivate 买家\n    deactivate 卖家\n\n```\n\n特点：\n* 商业信用提供的对象是企业再生产总资本的一部分。\n* 企业为了使再生产连续进行，不能长期将资本借出，商业信用一般只适用于短期借贷。\n\n\n*****\n#### 基于银行信用的交易类型：\n银行信用是银行和各类金融机构以货币形式提供的信用。银行信用是在商业信用基础上产生和发展起来的。\n\n```mermaid\n\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    participant 银行\n    买家->>银行:进行借款，形成债权和债务关系\n    activate 买家\n    activate 银行\n    deactivate 买家\n    deactivate 银行\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    买家->>卖家:进行支付，清偿债权和债务关系\n    deactivate 买家\n    deactivate 卖家\n    银行->>买家:收回借款，清偿债权和债务关系\n    activate 买家\n    activate 银行\n    deactivate 银行\n    deactivate 银行\n\n```\n\n## 支付结算概念\n是指单位、个人在社会经济活动中进行货币给付及资金清算的行为。\n\n\n\n\n","slug":"支付的基本概念","published":0,"date":"2018-04-08T02:00:13.602Z","updated":"2018-04-08T09:45:57.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxglc00001yoh9khu8iv2","content":"<h2 id=\"支付的本质\"><a href=\"#支付的本质\" class=\"headerlink\" title=\"支付的本质\"></a>支付的本质</h2><p>支付产生于交易，交易的存在是支付发生的前提。</p>\n<hr>\n<h2 id=\"支付的基本模型\"><a href=\"#支付的基本模型\" class=\"headerlink\" title=\"支付的基本模型\"></a>支付的基本模型</h2><h4 id=\"买卖交易类型：\"><a href=\"#买卖交易类型：\" class=\"headerlink\" title=\"买卖交易类型：\"></a>买卖交易类型：</h4><pre class=\"mermaid\">\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    买家-->>卖家:进行支付，清偿债权和债务关系\n    deactivate 买家\n    deactivate 卖家</pre>\n\n<p>在这个交易过程中：</p>\n<ul>\n<li>商品从卖家转移到买家，完成商品所有权的转移，形成债权和债务关系；</li>\n<li>买家通过现金或其它方式完成支付，清偿此债务，交易过程完成。</li>\n</ul>\n<hr>\n<h4 id=\"基于商业信用的交易类型：\"><a href=\"#基于商业信用的交易类型：\" class=\"headerlink\" title=\"基于商业信用的交易类型：\"></a>基于商业信用的交易类型：</h4><p>当卖家和买家建立了牢固的信用关系后，可基于信用进行交易。这种信用称为商业信用，其基本形式是赊销商品和预付货款。</p>\n<pre class=\"mermaid\">\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    deactivate 买家\n    deactivate 卖家\n    买家-->>卖家:延期或分期进行支付，清偿债权和债务关系\n    activate 买家\n    activate 卖家\n    deactivate 买家\n    deactivate 卖家</pre>\n\n<p>特点：</p>\n<ul>\n<li>商业信用提供的对象是企业再生产总资本的一部分。</li>\n<li>企业为了使再生产连续进行，不能长期将资本借出，商业信用一般只适用于短期借贷。</li>\n</ul>\n<hr>\n<h4 id=\"基于银行信用的交易类型：\"><a href=\"#基于银行信用的交易类型：\" class=\"headerlink\" title=\"基于银行信用的交易类型：\"></a>基于银行信用的交易类型：</h4><p>银行信用是银行和各类金融机构以货币形式提供的信用。银行信用是在商业信用基础上产生和发展起来的。</p>\n<pre class=\"mermaid\">\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    participant 银行\n    买家->>银行:进行借款，形成债权和债务关系\n    activate 买家\n    activate 银行\n    deactivate 买家\n    deactivate 银行\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    买家->>卖家:进行支付，清偿债权和债务关系\n    deactivate 买家\n    deactivate 卖家\n    银行->>买家:收回借款，清偿债权和债务关系\n    activate 买家\n    activate 银行\n    deactivate 银行\n    deactivate 银行</pre>\n\n<h2 id=\"支付结算概念\"><a href=\"#支付结算概念\" class=\"headerlink\" title=\"支付结算概念\"></a>支付结算概念</h2><p>是指单位、个人在社会经济活动中进行货币给付及资金清算的行为。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"支付的本质\"><a href=\"#支付的本质\" class=\"headerlink\" title=\"支付的本质\"></a>支付的本质</h2><p>支付产生于交易，交易的存在是支付发生的前提。</p>\n<hr>\n<h2 id=\"支付的基本模型\"><a href=\"#支付的基本模型\" class=\"headerlink\" title=\"支付的基本模型\"></a>支付的基本模型</h2><h4 id=\"买卖交易类型：\"><a href=\"#买卖交易类型：\" class=\"headerlink\" title=\"买卖交易类型：\"></a>买卖交易类型：</h4><pre class=\"mermaid\">\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    买家-->>卖家:进行支付，清偿债权和债务关系\n    deactivate 买家\n    deactivate 卖家</pre>\n\n<p>在这个交易过程中：</p>\n<ul>\n<li>商品从卖家转移到买家，完成商品所有权的转移，形成债权和债务关系；</li>\n<li>买家通过现金或其它方式完成支付，清偿此债务，交易过程完成。</li>\n</ul>\n<hr>\n<h4 id=\"基于商业信用的交易类型：\"><a href=\"#基于商业信用的交易类型：\" class=\"headerlink\" title=\"基于商业信用的交易类型：\"></a>基于商业信用的交易类型：</h4><p>当卖家和买家建立了牢固的信用关系后，可基于信用进行交易。这种信用称为商业信用，其基本形式是赊销商品和预付货款。</p>\n<pre class=\"mermaid\">\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    deactivate 买家\n    deactivate 卖家\n    买家-->>卖家:延期或分期进行支付，清偿债权和债务关系\n    activate 买家\n    activate 卖家\n    deactivate 买家\n    deactivate 卖家</pre>\n\n<p>特点：</p>\n<ul>\n<li>商业信用提供的对象是企业再生产总资本的一部分。</li>\n<li>企业为了使再生产连续进行，不能长期将资本借出，商业信用一般只适用于短期借贷。</li>\n</ul>\n<hr>\n<h4 id=\"基于银行信用的交易类型：\"><a href=\"#基于银行信用的交易类型：\" class=\"headerlink\" title=\"基于银行信用的交易类型：\"></a>基于银行信用的交易类型：</h4><p>银行信用是银行和各类金融机构以货币形式提供的信用。银行信用是在商业信用基础上产生和发展起来的。</p>\n<pre class=\"mermaid\">\nsequenceDiagram\n    participant 卖家\n    participant 买家\n    participant 银行\n    买家->>银行:进行借款，形成债权和债务关系\n    activate 买家\n    activate 银行\n    deactivate 买家\n    deactivate 银行\n    卖家->>买家: 商品转移，形成债权和债务关系\n    activate 买家\n    activate 卖家\n    买家->>卖家:进行支付，清偿债权和债务关系\n    deactivate 买家\n    deactivate 卖家\n    银行->>买家:收回借款，清偿债权和债务关系\n    activate 买家\n    activate 银行\n    deactivate 银行\n    deactivate 银行</pre>\n\n<h2 id=\"支付结算概念\"><a href=\"#支付结算概念\" class=\"headerlink\" title=\"支付结算概念\"></a>支付结算概念</h2><p>是指单位、个人在社会经济活动中进行货币给付及资金清算的行为。</p>\n"},{"title":"支付相关政策学习","_content":"## 《人民币银行结算账户管理办法》\n\n","source":"_drafts/支付相关政策学习.md","raw":"---\ntitle: 支付相关政策学习\ntags:\n   - 产品\n   - 支付\n---\n## 《人民币银行结算账户管理办法》\n\n","slug":"支付相关政策学习","published":0,"date":"2018-04-08T09:57:47.627Z","updated":"2018-04-08T09:59:27.336Z","_id":"cjfqmxgli00011yohfxtok43g","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"《人民币银行结算账户管理办法》\"><a href=\"#《人民币银行结算账户管理办法》\" class=\"headerlink\" title=\"《人民币银行结算账户管理办法》\"></a>《人民币银行结算账户管理办法》</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"《人民币银行结算账户管理办法》\"><a href=\"#《人民币银行结算账户管理办法》\" class=\"headerlink\" title=\"《人民币银行结算账户管理办法》\"></a>《人民币银行结算账户管理办法》</h2>"},{"title":"金融机构基本知识","_content":"\n## 金融机构定义\n指以货币资金为经营对象，从事货币信用、资金融通、金融交易以及相关业务的组织机构。\n\n*****\n\n## 金融机构分类\n通常分为银行与非银行金融机构两大类。\n\n#### 按监管隶属关系分类\n\n```mermaid\n\ngraph LR\n     金融机构 --- 中国人民银行               \n     金融机构 --- 中国银行保险监督管理委员会\n     金融机构 --- 中国证券监督管理委员会\n\n```\n\n#### 按银行与非银行业金融机构分类\n\n```mermaid\n\ngraph LR\n     金融机构 --- 银行业金融机构               \n     金融机构 --- 非银行业金融机构\n\n```\n\n```mermaid\n\ngraph LR\n     中国银行业金融机构 --- 政策性银行\n     中国银行业金融机构 --- 大型商业银行\n     中国银行业金融机构 --- 股份制商业银行\n     中国银行业金融机构 --- 邮政储蓄银行\n     中国银行业金融机构 --- 外资银行\n     中国银行业金融机构 --- 金融资产管理公司\n     中国银行业金融机构 --- 城市商业银行\n     中国银行业金融机构 --- 民营银行\n     中国银行业金融机构 --- 农商行\n     中国银行业金融机构 --- 农合行\n     中国银行业金融机构 --- 农信社\n     中国银行业金融机构 --- 三类新型农村金融机构\n     中国银行业金融机构 --- 信托公司\n     中国银行业金融机构 --- 财务公司\n     中国银行业金融机构 --- 金融租赁公司\n     中国银行业金融机构 --- 货币经纪公司\n     中国银行业金融机构 --- 消费金融公司\n\n```\n\n","source":"_drafts/金融机构基本知识.md","raw":"---\ntitle: 金融机构基本知识\ntags:\n   - 产品\n   - 支付\n---\n\n## 金融机构定义\n指以货币资金为经营对象，从事货币信用、资金融通、金融交易以及相关业务的组织机构。\n\n*****\n\n## 金融机构分类\n通常分为银行与非银行金融机构两大类。\n\n#### 按监管隶属关系分类\n\n```mermaid\n\ngraph LR\n     金融机构 --- 中国人民银行               \n     金融机构 --- 中国银行保险监督管理委员会\n     金融机构 --- 中国证券监督管理委员会\n\n```\n\n#### 按银行与非银行业金融机构分类\n\n```mermaid\n\ngraph LR\n     金融机构 --- 银行业金融机构               \n     金融机构 --- 非银行业金融机构\n\n```\n\n```mermaid\n\ngraph LR\n     中国银行业金融机构 --- 政策性银行\n     中国银行业金融机构 --- 大型商业银行\n     中国银行业金融机构 --- 股份制商业银行\n     中国银行业金融机构 --- 邮政储蓄银行\n     中国银行业金融机构 --- 外资银行\n     中国银行业金融机构 --- 金融资产管理公司\n     中国银行业金融机构 --- 城市商业银行\n     中国银行业金融机构 --- 民营银行\n     中国银行业金融机构 --- 农商行\n     中国银行业金融机构 --- 农合行\n     中国银行业金融机构 --- 农信社\n     中国银行业金融机构 --- 三类新型农村金融机构\n     中国银行业金融机构 --- 信托公司\n     中国银行业金融机构 --- 财务公司\n     中国银行业金融机构 --- 金融租赁公司\n     中国银行业金融机构 --- 货币经纪公司\n     中国银行业金融机构 --- 消费金融公司\n\n```\n\n","slug":"金融机构基本知识","published":0,"date":"2018-04-08T08:23:00.316Z","updated":"2018-04-08T09:36:30.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxglm00031yohcchtb4vk","content":"<h2 id=\"金融机构定义\"><a href=\"#金融机构定义\" class=\"headerlink\" title=\"金融机构定义\"></a>金融机构定义</h2><p>指以货币资金为经营对象，从事货币信用、资金融通、金融交易以及相关业务的组织机构。</p>\n<hr>\n<h2 id=\"金融机构分类\"><a href=\"#金融机构分类\" class=\"headerlink\" title=\"金融机构分类\"></a>金融机构分类</h2><p>通常分为银行与非银行金融机构两大类。</p>\n<h4 id=\"按监管隶属关系分类\"><a href=\"#按监管隶属关系分类\" class=\"headerlink\" title=\"按监管隶属关系分类\"></a>按监管隶属关系分类</h4><pre class=\"mermaid\">\ngraph LR\n     金融机构 --- 中国人民银行               \n     金融机构 --- 中国银行保险监督管理委员会\n     金融机构 --- 中国证券监督管理委员会</pre>\n\n<h4 id=\"按银行与非银行业金融机构分类\"><a href=\"#按银行与非银行业金融机构分类\" class=\"headerlink\" title=\"按银行与非银行业金融机构分类\"></a>按银行与非银行业金融机构分类</h4><pre class=\"mermaid\">\ngraph LR\n     金融机构 --- 银行业金融机构               \n     金融机构 --- 非银行业金融机构</pre>\n\n<pre class=\"mermaid\">\ngraph LR\n     中国银行业金融机构 --- 政策性银行\n     中国银行业金融机构 --- 大型商业银行\n     中国银行业金融机构 --- 股份制商业银行\n     中国银行业金融机构 --- 邮政储蓄银行\n     中国银行业金融机构 --- 外资银行\n     中国银行业金融机构 --- 金融资产管理公司\n     中国银行业金融机构 --- 城市商业银行\n     中国银行业金融机构 --- 民营银行\n     中国银行业金融机构 --- 农商行\n     中国银行业金融机构 --- 农合行\n     中国银行业金融机构 --- 农信社\n     中国银行业金融机构 --- 三类新型农村金融机构\n     中国银行业金融机构 --- 信托公司\n     中国银行业金融机构 --- 财务公司\n     中国银行业金融机构 --- 金融租赁公司\n     中国银行业金融机构 --- 货币经纪公司\n     中国银行业金融机构 --- 消费金融公司</pre>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"金融机构定义\"><a href=\"#金融机构定义\" class=\"headerlink\" title=\"金融机构定义\"></a>金融机构定义</h2><p>指以货币资金为经营对象，从事货币信用、资金融通、金融交易以及相关业务的组织机构。</p>\n<hr>\n<h2 id=\"金融机构分类\"><a href=\"#金融机构分类\" class=\"headerlink\" title=\"金融机构分类\"></a>金融机构分类</h2><p>通常分为银行与非银行金融机构两大类。</p>\n<h4 id=\"按监管隶属关系分类\"><a href=\"#按监管隶属关系分类\" class=\"headerlink\" title=\"按监管隶属关系分类\"></a>按监管隶属关系分类</h4><pre class=\"mermaid\">\ngraph LR\n     金融机构 --- 中国人民银行               \n     金融机构 --- 中国银行保险监督管理委员会\n     金融机构 --- 中国证券监督管理委员会</pre>\n\n<h4 id=\"按银行与非银行业金融机构分类\"><a href=\"#按银行与非银行业金融机构分类\" class=\"headerlink\" title=\"按银行与非银行业金融机构分类\"></a>按银行与非银行业金融机构分类</h4><pre class=\"mermaid\">\ngraph LR\n     金融机构 --- 银行业金融机构               \n     金融机构 --- 非银行业金融机构</pre>\n\n<pre class=\"mermaid\">\ngraph LR\n     中国银行业金融机构 --- 政策性银行\n     中国银行业金融机构 --- 大型商业银行\n     中国银行业金融机构 --- 股份制商业银行\n     中国银行业金融机构 --- 邮政储蓄银行\n     中国银行业金融机构 --- 外资银行\n     中国银行业金融机构 --- 金融资产管理公司\n     中国银行业金融机构 --- 城市商业银行\n     中国银行业金融机构 --- 民营银行\n     中国银行业金融机构 --- 农商行\n     中国银行业金融机构 --- 农合行\n     中国银行业金融机构 --- 农信社\n     中国银行业金融机构 --- 三类新型农村金融机构\n     中国银行业金融机构 --- 信托公司\n     中国银行业金融机构 --- 财务公司\n     中国银行业金融机构 --- 金融租赁公司\n     中国银行业金融机构 --- 货币经纪公司\n     中国银行业金融机构 --- 消费金融公司</pre>\n\n"},{"title":"Tornadoweb学习笔记","date":"2018-03-20T02:46:26.000Z","_content":"\n相关链接：\n官方文档：[http://www.tornadoweb.cn/](http://www.tornadoweb.cn/)\n\n*****\n## Tornado框架设计模型\n![Tornado框架设计模型](../img/Tornadokuangjia.png)\nTornado框架分为四层：\n* 最底层的EVENT层：处理IO事件；\n* TCP层实现TCP服务器，负责数据传输；\n* HTTP/HTTPS层基于HTTP协议实现HTTP服务器和客户端；\n* 最上层为WEB框架。\n\n*****\n## Tornado模块分类\n#### 主要模块\n* **tornado.web** - FriendFeed 使用的基础 Web 框架，包含了 Tornado 的大多数重要的功能；\n* **tornado.escape** -XHTML, JSON, URL 的编码/解码方法；\n* **tornado.options** -命令行和配置文件解析工具，针对服务器环境做了优化\n*****\n#### 底层模块\n* **tornado.httpserver** -服务于web模块的一个非常简单的HTTP服务器的实现；\n* **tornado.ioloop** - 核心的I/O循环\n\n*****\n## tornado.web\n#### Application()\n\n##### RequestHandler\nBase class for HTTP request handlers.\n\n\n\n*****\n## tornado.options\n#### parse_comand_line()\n解析命令行函数。\n#### define()\n\n*****\n## tornado.ioloop\n\n#### epoll\n**设备驱动：**操作系统和输入输出设备间的粘合剂。驱动负责将操作系统的请求传输，转化为特定物理设备控制器能够理解的命令。\n**I/O多路复用：**监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。\n##### poll机制\n为了减少CPU资源的占用率，在编写驱动函数中添加poll机制。poll（）是linux中的字符设备驱动中的一个函数，作用是把当前的文件指针挂到等待队列。\n\n**poll执行过程：**\n1、将用户传入的pollfd数组拷贝到内核空间；\n2、查询每个文件描述符对应设备的状态，如果该设备尚未就绪，则在该设备的等待队列中加入一项并继续查询下一设备的状态。查询完所有设备后如果没有一个设备就绪，这时则需要挂起当前进程等待，直到设备就绪或者超时，挂起操作是通过调用schedule_timeout执行的。设备就绪后进程被通知继续运行，这时再次遍历所有设备，以查找就绪设备；\n3、将获得的数据传送到用户空间并执行释放内存和剥离等待队列等善后工作。\n\n**epoll：**\n是linux内核为处理大批量文件描述符而改进的poll，能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。\n\n##其它\n####CSRF\ncross-site request forgery 跨站请求伪造\n\n\n\n\n","source":"_posts/Tornadoweb学习笔记.md","raw":"---\ntitle: Tornadoweb学习笔记\ndate: 2018-03-20 10:46:26\ntags:\n    - 开发\n    - 后端\n    - python\n---\n\n相关链接：\n官方文档：[http://www.tornadoweb.cn/](http://www.tornadoweb.cn/)\n\n*****\n## Tornado框架设计模型\n![Tornado框架设计模型](../img/Tornadokuangjia.png)\nTornado框架分为四层：\n* 最底层的EVENT层：处理IO事件；\n* TCP层实现TCP服务器，负责数据传输；\n* HTTP/HTTPS层基于HTTP协议实现HTTP服务器和客户端；\n* 最上层为WEB框架。\n\n*****\n## Tornado模块分类\n#### 主要模块\n* **tornado.web** - FriendFeed 使用的基础 Web 框架，包含了 Tornado 的大多数重要的功能；\n* **tornado.escape** -XHTML, JSON, URL 的编码/解码方法；\n* **tornado.options** -命令行和配置文件解析工具，针对服务器环境做了优化\n*****\n#### 底层模块\n* **tornado.httpserver** -服务于web模块的一个非常简单的HTTP服务器的实现；\n* **tornado.ioloop** - 核心的I/O循环\n\n*****\n## tornado.web\n#### Application()\n\n##### RequestHandler\nBase class for HTTP request handlers.\n\n\n\n*****\n## tornado.options\n#### parse_comand_line()\n解析命令行函数。\n#### define()\n\n*****\n## tornado.ioloop\n\n#### epoll\n**设备驱动：**操作系统和输入输出设备间的粘合剂。驱动负责将操作系统的请求传输，转化为特定物理设备控制器能够理解的命令。\n**I/O多路复用：**监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。\n##### poll机制\n为了减少CPU资源的占用率，在编写驱动函数中添加poll机制。poll（）是linux中的字符设备驱动中的一个函数，作用是把当前的文件指针挂到等待队列。\n\n**poll执行过程：**\n1、将用户传入的pollfd数组拷贝到内核空间；\n2、查询每个文件描述符对应设备的状态，如果该设备尚未就绪，则在该设备的等待队列中加入一项并继续查询下一设备的状态。查询完所有设备后如果没有一个设备就绪，这时则需要挂起当前进程等待，直到设备就绪或者超时，挂起操作是通过调用schedule_timeout执行的。设备就绪后进程被通知继续运行，这时再次遍历所有设备，以查找就绪设备；\n3、将获得的数据传送到用户空间并执行释放内存和剥离等待队列等善后工作。\n\n**epoll：**\n是linux内核为处理大批量文件描述符而改进的poll，能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。\n\n##其它\n####CSRF\ncross-site request forgery 跨站请求伪造\n\n\n\n\n","slug":"Tornadoweb学习笔记","published":1,"updated":"2018-03-30T08:32:18.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxglo00041yohtq6yvqjt","content":"<p>相关链接：<br>官方文档：<a href=\"http://www.tornadoweb.cn/\" target=\"_blank\" rel=\"noopener\">http://www.tornadoweb.cn/</a></p>\n<hr>\n<h2 id=\"Tornado框架设计模型\"><a href=\"#Tornado框架设计模型\" class=\"headerlink\" title=\"Tornado框架设计模型\"></a>Tornado框架设计模型</h2><p><img src=\"../img/Tornadokuangjia.png\" alt=\"Tornado框架设计模型\"><br>Tornado框架分为四层：</p>\n<ul>\n<li>最底层的EVENT层：处理IO事件；</li>\n<li>TCP层实现TCP服务器，负责数据传输；</li>\n<li>HTTP/HTTPS层基于HTTP协议实现HTTP服务器和客户端；</li>\n<li>最上层为WEB框架。</li>\n</ul>\n<hr>\n<h2 id=\"Tornado模块分类\"><a href=\"#Tornado模块分类\" class=\"headerlink\" title=\"Tornado模块分类\"></a>Tornado模块分类</h2><h4 id=\"主要模块\"><a href=\"#主要模块\" class=\"headerlink\" title=\"主要模块\"></a>主要模块</h4><ul>\n<li><strong>tornado.web</strong> - FriendFeed 使用的基础 Web 框架，包含了 Tornado 的大多数重要的功能；</li>\n<li><strong>tornado.escape</strong> -XHTML, JSON, URL 的编码/解码方法；</li>\n<li><strong>tornado.options</strong> -命令行和配置文件解析工具，针对服务器环境做了优化</li>\n</ul>\n<hr>\n<h4 id=\"底层模块\"><a href=\"#底层模块\" class=\"headerlink\" title=\"底层模块\"></a>底层模块</h4><ul>\n<li><strong>tornado.httpserver</strong> -服务于web模块的一个非常简单的HTTP服务器的实现；</li>\n<li><strong>tornado.ioloop</strong> - 核心的I/O循环</li>\n</ul>\n<hr>\n<h2 id=\"tornado-web\"><a href=\"#tornado-web\" class=\"headerlink\" title=\"tornado.web\"></a>tornado.web</h2><h4 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application()\"></a>Application()</h4><h5 id=\"RequestHandler\"><a href=\"#RequestHandler\" class=\"headerlink\" title=\"RequestHandler\"></a>RequestHandler</h5><p>Base class for HTTP request handlers.</p>\n<hr>\n<h2 id=\"tornado-options\"><a href=\"#tornado-options\" class=\"headerlink\" title=\"tornado.options\"></a>tornado.options</h2><h4 id=\"parse-comand-line\"><a href=\"#parse-comand-line\" class=\"headerlink\" title=\"parse_comand_line()\"></a>parse_comand_line()</h4><p>解析命令行函数。</p>\n<h4 id=\"define\"><a href=\"#define\" class=\"headerlink\" title=\"define()\"></a>define()</h4><hr>\n<h2 id=\"tornado-ioloop\"><a href=\"#tornado-ioloop\" class=\"headerlink\" title=\"tornado.ioloop\"></a>tornado.ioloop</h2><h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p><strong>设备驱动：</strong>操作系统和输入输出设备间的粘合剂。驱动负责将操作系统的请求传输，转化为特定物理设备控制器能够理解的命令。<br><strong>I/O多路复用：</strong>监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>\n<h5 id=\"poll机制\"><a href=\"#poll机制\" class=\"headerlink\" title=\"poll机制\"></a>poll机制</h5><p>为了减少CPU资源的占用率，在编写驱动函数中添加poll机制。poll（）是linux中的字符设备驱动中的一个函数，作用是把当前的文件指针挂到等待队列。</p>\n<p><strong>poll执行过程：</strong><br>1、将用户传入的pollfd数组拷贝到内核空间；<br>2、查询每个文件描述符对应设备的状态，如果该设备尚未就绪，则在该设备的等待队列中加入一项并继续查询下一设备的状态。查询完所有设备后如果没有一个设备就绪，这时则需要挂起当前进程等待，直到设备就绪或者超时，挂起操作是通过调用schedule_timeout执行的。设备就绪后进程被通知继续运行，这时再次遍历所有设备，以查找就绪设备；<br>3、将获得的数据传送到用户空间并执行释放内存和剥离等待队列等善后工作。</p>\n<p><strong>epoll：</strong><br>是linux内核为处理大批量文件描述符而改进的poll，能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>\n<p>##其它</p>\n<p>####CSRF<br>cross-site request forgery 跨站请求伪造</p>\n","site":{"data":{}},"excerpt":"","more":"<p>相关链接：<br>官方文档：<a href=\"http://www.tornadoweb.cn/\" target=\"_blank\" rel=\"noopener\">http://www.tornadoweb.cn/</a></p>\n<hr>\n<h2 id=\"Tornado框架设计模型\"><a href=\"#Tornado框架设计模型\" class=\"headerlink\" title=\"Tornado框架设计模型\"></a>Tornado框架设计模型</h2><p><img src=\"../img/Tornadokuangjia.png\" alt=\"Tornado框架设计模型\"><br>Tornado框架分为四层：</p>\n<ul>\n<li>最底层的EVENT层：处理IO事件；</li>\n<li>TCP层实现TCP服务器，负责数据传输；</li>\n<li>HTTP/HTTPS层基于HTTP协议实现HTTP服务器和客户端；</li>\n<li>最上层为WEB框架。</li>\n</ul>\n<hr>\n<h2 id=\"Tornado模块分类\"><a href=\"#Tornado模块分类\" class=\"headerlink\" title=\"Tornado模块分类\"></a>Tornado模块分类</h2><h4 id=\"主要模块\"><a href=\"#主要模块\" class=\"headerlink\" title=\"主要模块\"></a>主要模块</h4><ul>\n<li><strong>tornado.web</strong> - FriendFeed 使用的基础 Web 框架，包含了 Tornado 的大多数重要的功能；</li>\n<li><strong>tornado.escape</strong> -XHTML, JSON, URL 的编码/解码方法；</li>\n<li><strong>tornado.options</strong> -命令行和配置文件解析工具，针对服务器环境做了优化</li>\n</ul>\n<hr>\n<h4 id=\"底层模块\"><a href=\"#底层模块\" class=\"headerlink\" title=\"底层模块\"></a>底层模块</h4><ul>\n<li><strong>tornado.httpserver</strong> -服务于web模块的一个非常简单的HTTP服务器的实现；</li>\n<li><strong>tornado.ioloop</strong> - 核心的I/O循环</li>\n</ul>\n<hr>\n<h2 id=\"tornado-web\"><a href=\"#tornado-web\" class=\"headerlink\" title=\"tornado.web\"></a>tornado.web</h2><h4 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application()\"></a>Application()</h4><h5 id=\"RequestHandler\"><a href=\"#RequestHandler\" class=\"headerlink\" title=\"RequestHandler\"></a>RequestHandler</h5><p>Base class for HTTP request handlers.</p>\n<hr>\n<h2 id=\"tornado-options\"><a href=\"#tornado-options\" class=\"headerlink\" title=\"tornado.options\"></a>tornado.options</h2><h4 id=\"parse-comand-line\"><a href=\"#parse-comand-line\" class=\"headerlink\" title=\"parse_comand_line()\"></a>parse_comand_line()</h4><p>解析命令行函数。</p>\n<h4 id=\"define\"><a href=\"#define\" class=\"headerlink\" title=\"define()\"></a>define()</h4><hr>\n<h2 id=\"tornado-ioloop\"><a href=\"#tornado-ioloop\" class=\"headerlink\" title=\"tornado.ioloop\"></a>tornado.ioloop</h2><h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p><strong>设备驱动：</strong>操作系统和输入输出设备间的粘合剂。驱动负责将操作系统的请求传输，转化为特定物理设备控制器能够理解的命令。<br><strong>I/O多路复用：</strong>监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>\n<h5 id=\"poll机制\"><a href=\"#poll机制\" class=\"headerlink\" title=\"poll机制\"></a>poll机制</h5><p>为了减少CPU资源的占用率，在编写驱动函数中添加poll机制。poll（）是linux中的字符设备驱动中的一个函数，作用是把当前的文件指针挂到等待队列。</p>\n<p><strong>poll执行过程：</strong><br>1、将用户传入的pollfd数组拷贝到内核空间；<br>2、查询每个文件描述符对应设备的状态，如果该设备尚未就绪，则在该设备的等待队列中加入一项并继续查询下一设备的状态。查询完所有设备后如果没有一个设备就绪，这时则需要挂起当前进程等待，直到设备就绪或者超时，挂起操作是通过调用schedule_timeout执行的。设备就绪后进程被通知继续运行，这时再次遍历所有设备，以查找就绪设备；<br>3、将获得的数据传送到用户空间并执行释放内存和剥离等待队列等善后工作。</p>\n<p><strong>epoll：</strong><br>是linux内核为处理大批量文件描述符而改进的poll，能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>\n<p>##其它</p>\n<p>####CSRF<br>cross-site request forgery 跨站请求伪造</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-03-12T07:43:07.737Z","updated":"2018-03-12T07:43:07.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxglq00051yohda6qb2d1","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"linux学习笔记","date":"2018-03-21T04:16:39.000Z","_content":"## linux文件\nlinux中所有一切都是文件。\nlinux文件类型：\n* 普通文件\n* 目录\n* 设备文件\n* 套接口文件\n* 符号链接文件\n\n## 设备\nlinux设备分类：\n* 字符设备\n* 块设备\n* 网络设备\n\n#### 字符设备：\n指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。字符设备是面向流的设备。\n常见的字符设备：鼠标、键盘、串口、控制台和LED设备等。\n\n#### 块设备：\n指可以从设备的任意位置读取一定长度数据的设备。\n块设备包括：硬盘、磁盘、U盘和SD卡等。\n\n#### 网络接口：\n任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设备。\n\n## 进程\n一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度运行的基本单位。\n\n#### 进程VS程序：\n* 进程是程序的一次执行过程，是动态概念；程序是一组有序的指令集和，是静态概念；\n* 不同的进程可以执行同一个程序；\n\n#### 进程的声明周期：\n当操作系统要完成某个任务时，它会创建一个进程。当进程完成任务之后，系统就会撤销这个进程，收回它所占用的资源。从创建到撤销的时间段就是进程的生命期。\n\n#### 进程的组成：\n从结构上讲，每个进程都由程序、数据和一个进程控制块组成。\n\n#### 进程控制块：\nProcess Control Block，PCB。在linux中task_struct结构体即是PCB。PCB是进程的唯一标识。\nPCB包含信息：\n* 进程状态（state）\n* 进程标识信息（uid、gid）\n* 定时器（time）\n* 用户可见寄存器、控制状态寄存器、栈指针等\n\n#### 线程：\n有时被称为轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。\n\n*****\n## 进程通信\n\n\n*****\n## 存储结构\n数据的存储结构是指数据的逻辑结构在计算机中的表示。数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。\n* 顺序存储结构：逻辑上相邻的结点存储在物理位置相邻的存储单元里；通常借助数组来实现；\n* 链式存储结构：不要求逻辑上相邻的结点存储在物理位置相邻的存储单元里；通常借助指针来实现。\n\n#### 链表\n是一种物理存储单元上非连续、非顺序的存储结构。\n\n****\n## socket\n#### 地址族\naddress family，地址划分的标准集合，表示底层是使用哪种通信协议来递交数据的。如AF——INET使用TCP/IPv4；AF——INET6使用TCP/IPv6；AF——LOCAL或者AF——UNIX值本地通信。\n#### sin_family\n协议族\n\n*****\n#### 一些系统调用\n##### socket（）函数\n用户根据指定的地址族、数据类型和协议来分配一个套接口的 描述字 及其 所用的资源。\n```\nint socket（int af，int type，int protocol）\n```\n**af：**目前仅支持AF——INET格式；\n**type：**常用的有SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET；\n**protocol：**指定的协议,如调用者不想指定，可用0；\n\n##### bind（）函数\nbind()函数可以帮助你指定一个套接字使用的端口。\n```\nint bind(int socked, struct sockaddr *my_addr, int addrlen);\n```\n* **sockfd：**由socket（）函数返回的套接字描述符；\n* **my_addr：**指向struct sockaddr的指针；\n* **addrlen：**可以设置为sizeof（struct sockaddr）\n*****\n**sockaddr:**\nsockaddr在头文件#include<sys/socket.h>中定义，sa_data把目标地址和端口信息混在一起了。\n```\nstruct sockaddr {\n    sa_family_t sin_family;\n    char sa_data[14];\n    };\n```\nsockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。\n*****\n**sockaddr_in:**\nsockaddr_in在头文件#include <neine/in.h>或#include<arpa/inet.h>中定义，该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中。\n\n```\nstruct sockaddr_in{\n    sa_family_t     sin_family;\n    uint16_t        sin_port;\n    struct in_addr  sin_addr;\n    char            sin_zero[8];\n    }\n```\nsockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。\n\n\n\n","source":"_posts/linux学习笔记.md","raw":"---\ntitle: linux学习笔记\ndate: 2018-03-21 12:16:39\ntags:\n---\n## linux文件\nlinux中所有一切都是文件。\nlinux文件类型：\n* 普通文件\n* 目录\n* 设备文件\n* 套接口文件\n* 符号链接文件\n\n## 设备\nlinux设备分类：\n* 字符设备\n* 块设备\n* 网络设备\n\n#### 字符设备：\n指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。字符设备是面向流的设备。\n常见的字符设备：鼠标、键盘、串口、控制台和LED设备等。\n\n#### 块设备：\n指可以从设备的任意位置读取一定长度数据的设备。\n块设备包括：硬盘、磁盘、U盘和SD卡等。\n\n#### 网络接口：\n任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设备。\n\n## 进程\n一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度运行的基本单位。\n\n#### 进程VS程序：\n* 进程是程序的一次执行过程，是动态概念；程序是一组有序的指令集和，是静态概念；\n* 不同的进程可以执行同一个程序；\n\n#### 进程的声明周期：\n当操作系统要完成某个任务时，它会创建一个进程。当进程完成任务之后，系统就会撤销这个进程，收回它所占用的资源。从创建到撤销的时间段就是进程的生命期。\n\n#### 进程的组成：\n从结构上讲，每个进程都由程序、数据和一个进程控制块组成。\n\n#### 进程控制块：\nProcess Control Block，PCB。在linux中task_struct结构体即是PCB。PCB是进程的唯一标识。\nPCB包含信息：\n* 进程状态（state）\n* 进程标识信息（uid、gid）\n* 定时器（time）\n* 用户可见寄存器、控制状态寄存器、栈指针等\n\n#### 线程：\n有时被称为轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。\n\n*****\n## 进程通信\n\n\n*****\n## 存储结构\n数据的存储结构是指数据的逻辑结构在计算机中的表示。数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。\n* 顺序存储结构：逻辑上相邻的结点存储在物理位置相邻的存储单元里；通常借助数组来实现；\n* 链式存储结构：不要求逻辑上相邻的结点存储在物理位置相邻的存储单元里；通常借助指针来实现。\n\n#### 链表\n是一种物理存储单元上非连续、非顺序的存储结构。\n\n****\n## socket\n#### 地址族\naddress family，地址划分的标准集合，表示底层是使用哪种通信协议来递交数据的。如AF——INET使用TCP/IPv4；AF——INET6使用TCP/IPv6；AF——LOCAL或者AF——UNIX值本地通信。\n#### sin_family\n协议族\n\n*****\n#### 一些系统调用\n##### socket（）函数\n用户根据指定的地址族、数据类型和协议来分配一个套接口的 描述字 及其 所用的资源。\n```\nint socket（int af，int type，int protocol）\n```\n**af：**目前仅支持AF——INET格式；\n**type：**常用的有SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET；\n**protocol：**指定的协议,如调用者不想指定，可用0；\n\n##### bind（）函数\nbind()函数可以帮助你指定一个套接字使用的端口。\n```\nint bind(int socked, struct sockaddr *my_addr, int addrlen);\n```\n* **sockfd：**由socket（）函数返回的套接字描述符；\n* **my_addr：**指向struct sockaddr的指针；\n* **addrlen：**可以设置为sizeof（struct sockaddr）\n*****\n**sockaddr:**\nsockaddr在头文件#include<sys/socket.h>中定义，sa_data把目标地址和端口信息混在一起了。\n```\nstruct sockaddr {\n    sa_family_t sin_family;\n    char sa_data[14];\n    };\n```\nsockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。\n*****\n**sockaddr_in:**\nsockaddr_in在头文件#include <neine/in.h>或#include<arpa/inet.h>中定义，该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中。\n\n```\nstruct sockaddr_in{\n    sa_family_t     sin_family;\n    uint16_t        sin_port;\n    struct in_addr  sin_addr;\n    char            sin_zero[8];\n    }\n```\nsockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。\n\n\n\n","slug":"linux学习笔记","published":1,"updated":"2018-03-22T07:50:52.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxglt00071yohgxggdnp9","content":"<h2 id=\"linux文件\"><a href=\"#linux文件\" class=\"headerlink\" title=\"linux文件\"></a>linux文件</h2><p>linux中所有一切都是文件。<br>linux文件类型：</p>\n<ul>\n<li>普通文件</li>\n<li>目录</li>\n<li>设备文件</li>\n<li>套接口文件</li>\n<li>符号链接文件</li>\n</ul>\n<h2 id=\"设备\"><a href=\"#设备\" class=\"headerlink\" title=\"设备\"></a>设备</h2><p>linux设备分类：</p>\n<ul>\n<li>字符设备</li>\n<li>块设备</li>\n<li>网络设备</li>\n</ul>\n<h4 id=\"字符设备：\"><a href=\"#字符设备：\" class=\"headerlink\" title=\"字符设备：\"></a>字符设备：</h4><p>指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。字符设备是面向流的设备。<br>常见的字符设备：鼠标、键盘、串口、控制台和LED设备等。</p>\n<h4 id=\"块设备：\"><a href=\"#块设备：\" class=\"headerlink\" title=\"块设备：\"></a>块设备：</h4><p>指可以从设备的任意位置读取一定长度数据的设备。<br>块设备包括：硬盘、磁盘、U盘和SD卡等。</p>\n<h4 id=\"网络接口：\"><a href=\"#网络接口：\" class=\"headerlink\" title=\"网络接口：\"></a>网络接口：</h4><p>任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设备。</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度运行的基本单位。</p>\n<h4 id=\"进程VS程序：\"><a href=\"#进程VS程序：\" class=\"headerlink\" title=\"进程VS程序：\"></a>进程VS程序：</h4><ul>\n<li>进程是程序的一次执行过程，是动态概念；程序是一组有序的指令集和，是静态概念；</li>\n<li>不同的进程可以执行同一个程序；</li>\n</ul>\n<h4 id=\"进程的声明周期：\"><a href=\"#进程的声明周期：\" class=\"headerlink\" title=\"进程的声明周期：\"></a>进程的声明周期：</h4><p>当操作系统要完成某个任务时，它会创建一个进程。当进程完成任务之后，系统就会撤销这个进程，收回它所占用的资源。从创建到撤销的时间段就是进程的生命期。</p>\n<h4 id=\"进程的组成：\"><a href=\"#进程的组成：\" class=\"headerlink\" title=\"进程的组成：\"></a>进程的组成：</h4><p>从结构上讲，每个进程都由程序、数据和一个进程控制块组成。</p>\n<h4 id=\"进程控制块：\"><a href=\"#进程控制块：\" class=\"headerlink\" title=\"进程控制块：\"></a>进程控制块：</h4><p>Process Control Block，PCB。在linux中task_struct结构体即是PCB。PCB是进程的唯一标识。<br>PCB包含信息：</p>\n<ul>\n<li>进程状态（state）</li>\n<li>进程标识信息（uid、gid）</li>\n<li>定时器（time）</li>\n<li>用户可见寄存器、控制状态寄存器、栈指针等</li>\n</ul>\n<h4 id=\"线程：\"><a href=\"#线程：\" class=\"headerlink\" title=\"线程：\"></a>线程：</h4><p>有时被称为轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。</p>\n<hr>\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><hr>\n<h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><p>数据的存储结构是指数据的逻辑结构在计算机中的表示。数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。</p>\n<ul>\n<li>顺序存储结构：逻辑上相邻的结点存储在物理位置相邻的存储单元里；通常借助数组来实现；</li>\n<li>链式存储结构：不要求逻辑上相邻的结点存储在物理位置相邻的存储单元里；通常借助指针来实现。</li>\n</ul>\n<h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><p>是一种物理存储单元上非连续、非顺序的存储结构。</p>\n<hr>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><h4 id=\"地址族\"><a href=\"#地址族\" class=\"headerlink\" title=\"地址族\"></a>地址族</h4><p>address family，地址划分的标准集合，表示底层是使用哪种通信协议来递交数据的。如AF——INET使用TCP/IPv4；AF——INET6使用TCP/IPv6；AF——LOCAL或者AF——UNIX值本地通信。</p>\n<h4 id=\"sin-family\"><a href=\"#sin-family\" class=\"headerlink\" title=\"sin_family\"></a>sin_family</h4><p>协议族</p>\n<hr>\n<h4 id=\"一些系统调用\"><a href=\"#一些系统调用\" class=\"headerlink\" title=\"一些系统调用\"></a>一些系统调用</h4><h5 id=\"socket（）函数\"><a href=\"#socket（）函数\" class=\"headerlink\" title=\"socket（）函数\"></a>socket（）函数</h5><p>用户根据指定的地址族、数据类型和协议来分配一个套接口的 描述字 及其 所用的资源。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int socket（int af，int type，int protocol）</span><br></pre></td></tr></table></figure></p>\n<p><strong>af：</strong>目前仅支持AF——INET格式；<br><strong>type：</strong>常用的有SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET；<br><strong>protocol：</strong>指定的协议,如调用者不想指定，可用0；</p>\n<h5 id=\"bind（）函数\"><a href=\"#bind（）函数\" class=\"headerlink\" title=\"bind（）函数\"></a>bind（）函数</h5><p>bind()函数可以帮助你指定一个套接字使用的端口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int bind(int socked, struct sockaddr *my_addr, int addrlen);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>sockfd：</strong>由socket（）函数返回的套接字描述符；</li>\n<li><strong>my_addr：</strong>指向struct sockaddr的指针；</li>\n<li><strong>addrlen：</strong>可以设置为sizeof（struct sockaddr）</li>\n</ul>\n<hr>\n<p><strong>sockaddr:</strong><br>sockaddr在头文件#include&lt;sys/socket.h&gt;中定义，sa_data把目标地址和端口信息混在一起了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct sockaddr &#123;</span><br><span class=\"line\">    sa_family_t sin_family;</span><br><span class=\"line\">    char sa_data[14];</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。</p>\n<hr>\n<p><strong>sockaddr_in:</strong><br>sockaddr_in在头文件#include &lt;neine/in.h&gt;或#include&lt;arpa/inet.h&gt;中定义，该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct sockaddr_in&#123;</span><br><span class=\"line\">    sa_family_t     sin_family;</span><br><span class=\"line\">    uint16_t        sin_port;</span><br><span class=\"line\">    struct in_addr  sin_addr;</span><br><span class=\"line\">    char            sin_zero[8];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"linux文件\"><a href=\"#linux文件\" class=\"headerlink\" title=\"linux文件\"></a>linux文件</h2><p>linux中所有一切都是文件。<br>linux文件类型：</p>\n<ul>\n<li>普通文件</li>\n<li>目录</li>\n<li>设备文件</li>\n<li>套接口文件</li>\n<li>符号链接文件</li>\n</ul>\n<h2 id=\"设备\"><a href=\"#设备\" class=\"headerlink\" title=\"设备\"></a>设备</h2><p>linux设备分类：</p>\n<ul>\n<li>字符设备</li>\n<li>块设备</li>\n<li>网络设备</li>\n</ul>\n<h4 id=\"字符设备：\"><a href=\"#字符设备：\" class=\"headerlink\" title=\"字符设备：\"></a>字符设备：</h4><p>指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。字符设备是面向流的设备。<br>常见的字符设备：鼠标、键盘、串口、控制台和LED设备等。</p>\n<h4 id=\"块设备：\"><a href=\"#块设备：\" class=\"headerlink\" title=\"块设备：\"></a>块设备：</h4><p>指可以从设备的任意位置读取一定长度数据的设备。<br>块设备包括：硬盘、磁盘、U盘和SD卡等。</p>\n<h4 id=\"网络接口：\"><a href=\"#网络接口：\" class=\"headerlink\" title=\"网络接口：\"></a>网络接口：</h4><p>任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设备。</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度运行的基本单位。</p>\n<h4 id=\"进程VS程序：\"><a href=\"#进程VS程序：\" class=\"headerlink\" title=\"进程VS程序：\"></a>进程VS程序：</h4><ul>\n<li>进程是程序的一次执行过程，是动态概念；程序是一组有序的指令集和，是静态概念；</li>\n<li>不同的进程可以执行同一个程序；</li>\n</ul>\n<h4 id=\"进程的声明周期：\"><a href=\"#进程的声明周期：\" class=\"headerlink\" title=\"进程的声明周期：\"></a>进程的声明周期：</h4><p>当操作系统要完成某个任务时，它会创建一个进程。当进程完成任务之后，系统就会撤销这个进程，收回它所占用的资源。从创建到撤销的时间段就是进程的生命期。</p>\n<h4 id=\"进程的组成：\"><a href=\"#进程的组成：\" class=\"headerlink\" title=\"进程的组成：\"></a>进程的组成：</h4><p>从结构上讲，每个进程都由程序、数据和一个进程控制块组成。</p>\n<h4 id=\"进程控制块：\"><a href=\"#进程控制块：\" class=\"headerlink\" title=\"进程控制块：\"></a>进程控制块：</h4><p>Process Control Block，PCB。在linux中task_struct结构体即是PCB。PCB是进程的唯一标识。<br>PCB包含信息：</p>\n<ul>\n<li>进程状态（state）</li>\n<li>进程标识信息（uid、gid）</li>\n<li>定时器（time）</li>\n<li>用户可见寄存器、控制状态寄存器、栈指针等</li>\n</ul>\n<h4 id=\"线程：\"><a href=\"#线程：\" class=\"headerlink\" title=\"线程：\"></a>线程：</h4><p>有时被称为轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。</p>\n<hr>\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><hr>\n<h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><p>数据的存储结构是指数据的逻辑结构在计算机中的表示。数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。</p>\n<ul>\n<li>顺序存储结构：逻辑上相邻的结点存储在物理位置相邻的存储单元里；通常借助数组来实现；</li>\n<li>链式存储结构：不要求逻辑上相邻的结点存储在物理位置相邻的存储单元里；通常借助指针来实现。</li>\n</ul>\n<h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><p>是一种物理存储单元上非连续、非顺序的存储结构。</p>\n<hr>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><h4 id=\"地址族\"><a href=\"#地址族\" class=\"headerlink\" title=\"地址族\"></a>地址族</h4><p>address family，地址划分的标准集合，表示底层是使用哪种通信协议来递交数据的。如AF——INET使用TCP/IPv4；AF——INET6使用TCP/IPv6；AF——LOCAL或者AF——UNIX值本地通信。</p>\n<h4 id=\"sin-family\"><a href=\"#sin-family\" class=\"headerlink\" title=\"sin_family\"></a>sin_family</h4><p>协议族</p>\n<hr>\n<h4 id=\"一些系统调用\"><a href=\"#一些系统调用\" class=\"headerlink\" title=\"一些系统调用\"></a>一些系统调用</h4><h5 id=\"socket（）函数\"><a href=\"#socket（）函数\" class=\"headerlink\" title=\"socket（）函数\"></a>socket（）函数</h5><p>用户根据指定的地址族、数据类型和协议来分配一个套接口的 描述字 及其 所用的资源。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int socket（int af，int type，int protocol）</span><br></pre></td></tr></table></figure></p>\n<p><strong>af：</strong>目前仅支持AF——INET格式；<br><strong>type：</strong>常用的有SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET；<br><strong>protocol：</strong>指定的协议,如调用者不想指定，可用0；</p>\n<h5 id=\"bind（）函数\"><a href=\"#bind（）函数\" class=\"headerlink\" title=\"bind（）函数\"></a>bind（）函数</h5><p>bind()函数可以帮助你指定一个套接字使用的端口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int bind(int socked, struct sockaddr *my_addr, int addrlen);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>sockfd：</strong>由socket（）函数返回的套接字描述符；</li>\n<li><strong>my_addr：</strong>指向struct sockaddr的指针；</li>\n<li><strong>addrlen：</strong>可以设置为sizeof（struct sockaddr）</li>\n</ul>\n<hr>\n<p><strong>sockaddr:</strong><br>sockaddr在头文件#include&lt;sys/socket.h&gt;中定义，sa_data把目标地址和端口信息混在一起了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct sockaddr &#123;</span><br><span class=\"line\">    sa_family_t sin_family;</span><br><span class=\"line\">    char sa_data[14];</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。</p>\n<hr>\n<p><strong>sockaddr_in:</strong><br>sockaddr_in在头文件#include &lt;neine/in.h&gt;或#include&lt;arpa/inet.h&gt;中定义，该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct sockaddr_in&#123;</span><br><span class=\"line\">    sa_family_t     sin_family;</span><br><span class=\"line\">    uint16_t        sin_port;</span><br><span class=\"line\">    struct in_addr  sin_addr;</span><br><span class=\"line\">    char            sin_zero[8];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。</p>\n"},{"title":"pug和hexo学习笔记","date":"2018-03-29T02:31:02.000Z","_content":"\n## pug学习\n#### pug编译\n输入\n```\npug filename.pug\n```\n生成html文件；\n若输入\n```\npug -P -w filename.pug \n```\n可以监听并自动更新。\n\n#### 分支条件\n```\n- var friends=0\n    case friends\n        when 10\n         p 您没有朋友\n        default\n         p 您有#{friends}个朋友\n```\n渲染结果：\n您有10个朋友\n\n#### Mixin混入\n混入是一种允许在 Pug 中重复使用一整个代码块的方法。\n```\nmixin list\n ul\n   li foo\n+list\n+list\n```\n渲染结果：\n* foo\n* foo\n\n## hexo学习\n**hexo官方网址：**[https://hexo.io/docs/](https://hexo.io/docs/)\n*****\n**hexo本地测试注意点：**\n修改hexo根目录下的_config.yml站点配置目录后，要重新启动hexo再刷新，修改theme主题目录下的_config.yml主题配置目录则只需刷新即可。\n\n\n","source":"_posts/pug和hexo学习笔记.md","raw":"---\ntitle: pug和hexo学习笔记\ndate: 2018-03-29 10:31:02\ntags:\n    - 开发\n    - 前端\n---\n\n## pug学习\n#### pug编译\n输入\n```\npug filename.pug\n```\n生成html文件；\n若输入\n```\npug -P -w filename.pug \n```\n可以监听并自动更新。\n\n#### 分支条件\n```\n- var friends=0\n    case friends\n        when 10\n         p 您没有朋友\n        default\n         p 您有#{friends}个朋友\n```\n渲染结果：\n您有10个朋友\n\n#### Mixin混入\n混入是一种允许在 Pug 中重复使用一整个代码块的方法。\n```\nmixin list\n ul\n   li foo\n+list\n+list\n```\n渲染结果：\n* foo\n* foo\n\n## hexo学习\n**hexo官方网址：**[https://hexo.io/docs/](https://hexo.io/docs/)\n*****\n**hexo本地测试注意点：**\n修改hexo根目录下的_config.yml站点配置目录后，要重新启动hexo再刷新，修改theme主题目录下的_config.yml主题配置目录则只需刷新即可。\n\n\n","slug":"pug和hexo学习笔记","published":1,"updated":"2018-03-29T02:32:34.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxglv00081yohg0hc1y07","content":"<h2 id=\"pug学习\"><a href=\"#pug学习\" class=\"headerlink\" title=\"pug学习\"></a>pug学习</h2><h4 id=\"pug编译\"><a href=\"#pug编译\" class=\"headerlink\" title=\"pug编译\"></a>pug编译</h4><p>输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pug filename.pug</span><br></pre></td></tr></table></figure></p>\n<p>生成html文件；<br>若输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pug -P -w filename.pug</span><br></pre></td></tr></table></figure></p>\n<p>可以监听并自动更新。</p>\n<h4 id=\"分支条件\"><a href=\"#分支条件\" class=\"headerlink\" title=\"分支条件\"></a>分支条件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var friends=0</span><br><span class=\"line\">    case friends</span><br><span class=\"line\">        when 10</span><br><span class=\"line\">         p 您没有朋友</span><br><span class=\"line\">        default</span><br><span class=\"line\">         p 您有#&#123;friends&#125;个朋友</span><br></pre></td></tr></table></figure>\n<p>渲染结果：<br>您有10个朋友</p>\n<h4 id=\"Mixin混入\"><a href=\"#Mixin混入\" class=\"headerlink\" title=\"Mixin混入\"></a>Mixin混入</h4><p>混入是一种允许在 Pug 中重复使用一整个代码块的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin list</span><br><span class=\"line\"> ul</span><br><span class=\"line\">   li foo</span><br><span class=\"line\">+list</span><br><span class=\"line\">+list</span><br></pre></td></tr></table></figure></p>\n<p>渲染结果：</p>\n<ul>\n<li>foo</li>\n<li>foo</li>\n</ul>\n<h2 id=\"hexo学习\"><a href=\"#hexo学习\" class=\"headerlink\" title=\"hexo学习\"></a>hexo学习</h2><p><strong>hexo官方网址：</strong><a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/docs/</a></p>\n<hr>\n<p><strong>hexo本地测试注意点：</strong><br>修改hexo根目录下的_config.yml站点配置目录后，要重新启动hexo再刷新，修改theme主题目录下的_config.yml主题配置目录则只需刷新即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"pug学习\"><a href=\"#pug学习\" class=\"headerlink\" title=\"pug学习\"></a>pug学习</h2><h4 id=\"pug编译\"><a href=\"#pug编译\" class=\"headerlink\" title=\"pug编译\"></a>pug编译</h4><p>输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pug filename.pug</span><br></pre></td></tr></table></figure></p>\n<p>生成html文件；<br>若输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pug -P -w filename.pug</span><br></pre></td></tr></table></figure></p>\n<p>可以监听并自动更新。</p>\n<h4 id=\"分支条件\"><a href=\"#分支条件\" class=\"headerlink\" title=\"分支条件\"></a>分支条件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var friends=0</span><br><span class=\"line\">    case friends</span><br><span class=\"line\">        when 10</span><br><span class=\"line\">         p 您没有朋友</span><br><span class=\"line\">        default</span><br><span class=\"line\">         p 您有#&#123;friends&#125;个朋友</span><br></pre></td></tr></table></figure>\n<p>渲染结果：<br>您有10个朋友</p>\n<h4 id=\"Mixin混入\"><a href=\"#Mixin混入\" class=\"headerlink\" title=\"Mixin混入\"></a>Mixin混入</h4><p>混入是一种允许在 Pug 中重复使用一整个代码块的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin list</span><br><span class=\"line\"> ul</span><br><span class=\"line\">   li foo</span><br><span class=\"line\">+list</span><br><span class=\"line\">+list</span><br></pre></td></tr></table></figure></p>\n<p>渲染结果：</p>\n<ul>\n<li>foo</li>\n<li>foo</li>\n</ul>\n<h2 id=\"hexo学习\"><a href=\"#hexo学习\" class=\"headerlink\" title=\"hexo学习\"></a>hexo学习</h2><p><strong>hexo官方网址：</strong><a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/docs/</a></p>\n<hr>\n<p><strong>hexo本地测试注意点：</strong><br>修改hexo根目录下的_config.yml站点配置目录后，要重新启动hexo再刷新，修改theme主题目录下的_config.yml主题配置目录则只需刷新即可。</p>\n"},{"title":"python 面向对象技术","date":"2018-03-29T04:22:14.000Z","_content":"python是一门面向对象的语言，在python中一切都是对象。&lt;type'object'&gt;和&lt;type'type'&gt;是python两个最基本的对象，是所有对象的起源。\n\n<!--more--> \n\n**python对象有三个基本要素：**\n* 身份：对象的唯一性身份标志，是该对象的内存地址；\n* 类型：对象的类型决定了该对象可以保存什么类型的值，可进行什么样的操作；\n* 值：对象代表的数据\n\n**&lt;type'object'&gt;和&lt;type'type'&gt;：**\n```\nprint (object)\nprint(type(object))\nprint(object.__class__)\nprint(object.__bases__)\n\nprint()\n\nprint(type)\nprint(type(type))\nprint(type.__class__)\nprint(type.__bases__)\n```\n输出值：\n&lt;class 'object'&gt;\n&lt;class 'type'&gt;\n&lt;class 'type'&gt;\n()\n\n&lt;class 'type'&gt;\n&lt;class 'type'&gt;\n&lt;class 'type'&gt;\n(&lt;class 'object'&gt;,)\n\n*****\n说明:\n* &lt;type'object'&gt;的类型是&lt;type'type'&gt;\n* &lt;type'type'&gt;的类型是它本身；\n* &lt;type'object'&gt;没有父类；\n* &lt;type'type'&gt;的父类是&lt;type'object'&gt;\n\n\n\n## 类和实例\n类是抽象的模板，实例是根据类创建出来的一个具体的对象。各个实例拥有的数据都互相独立，互不影响。\n*****\n**举例：**\n*****\n类Student：\n```\nclass Student（object）：\n  pass\n```\n实例bart：\n```\nbart=Student（）\n```\n给实例变量绑定属性：\n```\nbart.name='Bart Simpson'\n```\n*****\n## 方法\n方法是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据。\n\n\n## 类的继承\n实现代码重用的方法之一是通过继承机制。\n**继承语法：** class 派生类名（基类名）：\n\n在python中继承的特点：\n* 在继承中基类的构造（__init__()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用；\n* 在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别在于类中调用普通函数时并不需要带上self参数；\n* Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）；\n* 如果在继承元组中列了一个以上的类，那么它就被称作\"多重继承\" 。\n\n#### 多重继承\n\n\n","source":"_posts/python-面向对象技术.md","raw":"---\ntitle: python 面向对象技术\ndate: 2018-03-29 12:22:14\ntags:\n    - 开发\n    - 后端\n    - python\n---\npython是一门面向对象的语言，在python中一切都是对象。&lt;type'object'&gt;和&lt;type'type'&gt;是python两个最基本的对象，是所有对象的起源。\n\n<!--more--> \n\n**python对象有三个基本要素：**\n* 身份：对象的唯一性身份标志，是该对象的内存地址；\n* 类型：对象的类型决定了该对象可以保存什么类型的值，可进行什么样的操作；\n* 值：对象代表的数据\n\n**&lt;type'object'&gt;和&lt;type'type'&gt;：**\n```\nprint (object)\nprint(type(object))\nprint(object.__class__)\nprint(object.__bases__)\n\nprint()\n\nprint(type)\nprint(type(type))\nprint(type.__class__)\nprint(type.__bases__)\n```\n输出值：\n&lt;class 'object'&gt;\n&lt;class 'type'&gt;\n&lt;class 'type'&gt;\n()\n\n&lt;class 'type'&gt;\n&lt;class 'type'&gt;\n&lt;class 'type'&gt;\n(&lt;class 'object'&gt;,)\n\n*****\n说明:\n* &lt;type'object'&gt;的类型是&lt;type'type'&gt;\n* &lt;type'type'&gt;的类型是它本身；\n* &lt;type'object'&gt;没有父类；\n* &lt;type'type'&gt;的父类是&lt;type'object'&gt;\n\n\n\n## 类和实例\n类是抽象的模板，实例是根据类创建出来的一个具体的对象。各个实例拥有的数据都互相独立，互不影响。\n*****\n**举例：**\n*****\n类Student：\n```\nclass Student（object）：\n  pass\n```\n实例bart：\n```\nbart=Student（）\n```\n给实例变量绑定属性：\n```\nbart.name='Bart Simpson'\n```\n*****\n## 方法\n方法是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据。\n\n\n## 类的继承\n实现代码重用的方法之一是通过继承机制。\n**继承语法：** class 派生类名（基类名）：\n\n在python中继承的特点：\n* 在继承中基类的构造（__init__()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用；\n* 在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别在于类中调用普通函数时并不需要带上self参数；\n* Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）；\n* 如果在继承元组中列了一个以上的类，那么它就被称作\"多重继承\" 。\n\n#### 多重继承\n\n\n","slug":"python-面向对象技术","published":1,"updated":"2018-03-30T07:43:45.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxgly000a1yoh20ykef3u","content":"<p>python是一门面向对象的语言，在python中一切都是对象。&lt;type’object’&gt;和&lt;type’type’&gt;是python两个最基本的对象，是所有对象的起源。</p>\n<a id=\"more\"></a> \n<p><strong>python对象有三个基本要素：</strong></p>\n<ul>\n<li>身份：对象的唯一性身份标志，是该对象的内存地址；</li>\n<li>类型：对象的类型决定了该对象可以保存什么类型的值，可进行什么样的操作；</li>\n<li>值：对象代表的数据</li>\n</ul>\n<p><strong>&lt;type’object’&gt;和&lt;type’type’&gt;：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print (object)</span><br><span class=\"line\">print(type(object))</span><br><span class=\"line\">print(object.__class__)</span><br><span class=\"line\">print(object.__bases__)</span><br><span class=\"line\"></span><br><span class=\"line\">print()</span><br><span class=\"line\"></span><br><span class=\"line\">print(type)</span><br><span class=\"line\">print(type(type))</span><br><span class=\"line\">print(type.__class__)</span><br><span class=\"line\">print(type.__bases__)</span><br></pre></td></tr></table></figure></p>\n<p>输出值：<br>&lt;class ‘object’&gt;<br>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>()</p>\n<p>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>(&lt;class ‘object’&gt;,)</p>\n<hr>\n<p>说明:</p>\n<ul>\n<li>&lt;type’object’&gt;的类型是&lt;type’type’&gt;</li>\n<li>&lt;type’type’&gt;的类型是它本身；</li>\n<li>&lt;type’object’&gt;没有父类；</li>\n<li>&lt;type’type’&gt;的父类是&lt;type’object’&gt;</li>\n</ul>\n<h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><p>类是抽象的模板，实例是根据类创建出来的一个具体的对象。各个实例拥有的数据都互相独立，互不影响。</p>\n<hr>\n<p><strong>举例：</strong></p>\n<hr>\n<p>类Student：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student（object）：</span><br><span class=\"line\">  pass</span><br></pre></td></tr></table></figure></p>\n<p>实例bart：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bart=Student（）</span><br></pre></td></tr></table></figure></p>\n<p>给实例变量绑定属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bart.name=&apos;Bart Simpson&apos;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据。</p>\n<h2 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h2><p>实现代码重用的方法之一是通过继承机制。<br><strong>继承语法：</strong> class 派生类名（基类名）：</p>\n<p>在python中继承的特点：</p>\n<ul>\n<li>在继承中基类的构造（<strong>init</strong>()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用；</li>\n<li>在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别在于类中调用普通函数时并不需要带上self参数；</li>\n<li>Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）；</li>\n<li>如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。</li>\n</ul>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4>","site":{"data":{}},"excerpt":"<p>python是一门面向对象的语言，在python中一切都是对象。&lt;type’object’&gt;和&lt;type’type’&gt;是python两个最基本的对象，是所有对象的起源。</p>","more":"<p><strong>python对象有三个基本要素：</strong></p>\n<ul>\n<li>身份：对象的唯一性身份标志，是该对象的内存地址；</li>\n<li>类型：对象的类型决定了该对象可以保存什么类型的值，可进行什么样的操作；</li>\n<li>值：对象代表的数据</li>\n</ul>\n<p><strong>&lt;type’object’&gt;和&lt;type’type’&gt;：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print (object)</span><br><span class=\"line\">print(type(object))</span><br><span class=\"line\">print(object.__class__)</span><br><span class=\"line\">print(object.__bases__)</span><br><span class=\"line\"></span><br><span class=\"line\">print()</span><br><span class=\"line\"></span><br><span class=\"line\">print(type)</span><br><span class=\"line\">print(type(type))</span><br><span class=\"line\">print(type.__class__)</span><br><span class=\"line\">print(type.__bases__)</span><br></pre></td></tr></table></figure></p>\n<p>输出值：<br>&lt;class ‘object’&gt;<br>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>()</p>\n<p>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>(&lt;class ‘object’&gt;,)</p>\n<hr>\n<p>说明:</p>\n<ul>\n<li>&lt;type’object’&gt;的类型是&lt;type’type’&gt;</li>\n<li>&lt;type’type’&gt;的类型是它本身；</li>\n<li>&lt;type’object’&gt;没有父类；</li>\n<li>&lt;type’type’&gt;的父类是&lt;type’object’&gt;</li>\n</ul>\n<h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><p>类是抽象的模板，实例是根据类创建出来的一个具体的对象。各个实例拥有的数据都互相独立，互不影响。</p>\n<hr>\n<p><strong>举例：</strong></p>\n<hr>\n<p>类Student：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student（object）：</span><br><span class=\"line\">  pass</span><br></pre></td></tr></table></figure></p>\n<p>实例bart：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bart=Student（）</span><br></pre></td></tr></table></figure></p>\n<p>给实例变量绑定属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bart.name=&apos;Bart Simpson&apos;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据。</p>\n<h2 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h2><p>实现代码重用的方法之一是通过继承机制。<br><strong>继承语法：</strong> class 派生类名（基类名）：</p>\n<p>在python中继承的特点：</p>\n<ul>\n<li>在继承中基类的构造（<strong>init</strong>()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用；</li>\n<li>在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别在于类中调用普通函数时并不需要带上self参数；</li>\n<li>Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）；</li>\n<li>如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。</li>\n</ul>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4>"},{"title":"python变量","date":"2018-03-29T03:29:09.000Z","_content":"\n创建变量时会在内存中开辟一个空间。基于变量的数据类型，解释器会分配指定内存。\n\n## python的数据类型\npython有五个标准的数据类型：\n* numbers：数字\n* string：字符串\n* list：列表\n* tuple：元组\n* dictionary：字典\n\n#### numbers\n\n#### list\n列表用`[]`标识。列表是有序的对象集合。\n\n#### tuple\n元组用`()`标识，内部元素用`,`隔开。\n\n#### dictionary\n字典用`{}`标识。字典由索引（key）和它对应的值value组成，字典是无序的对象集合。\n","source":"_posts/python变量.md","raw":"---\ntitle: python变量\ndate: 2018-03-29 11:29:09\ntags:\n    - 开发\n    - 后端\n    - python\n---\n\n创建变量时会在内存中开辟一个空间。基于变量的数据类型，解释器会分配指定内存。\n\n## python的数据类型\npython有五个标准的数据类型：\n* numbers：数字\n* string：字符串\n* list：列表\n* tuple：元组\n* dictionary：字典\n\n#### numbers\n\n#### list\n列表用`[]`标识。列表是有序的对象集合。\n\n#### tuple\n元组用`()`标识，内部元素用`,`隔开。\n\n#### dictionary\n字典用`{}`标识。字典由索引（key）和它对应的值value组成，字典是无序的对象集合。\n","slug":"python变量","published":1,"updated":"2018-03-29T04:16:35.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxgm0000c1yohfy986iio","content":"<p>创建变量时会在内存中开辟一个空间。基于变量的数据类型，解释器会分配指定内存。</p>\n<h2 id=\"python的数据类型\"><a href=\"#python的数据类型\" class=\"headerlink\" title=\"python的数据类型\"></a>python的数据类型</h2><p>python有五个标准的数据类型：</p>\n<ul>\n<li>numbers：数字</li>\n<li>string：字符串</li>\n<li>list：列表</li>\n<li>tuple：元组</li>\n<li>dictionary：字典</li>\n</ul>\n<h4 id=\"numbers\"><a href=\"#numbers\" class=\"headerlink\" title=\"numbers\"></a>numbers</h4><h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p>列表用<code>[]</code>标识。列表是有序的对象集合。</p>\n<h4 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h4><p>元组用<code>()</code>标识，内部元素用<code>,</code>隔开。</p>\n<h4 id=\"dictionary\"><a href=\"#dictionary\" class=\"headerlink\" title=\"dictionary\"></a>dictionary</h4><p>字典用<code>{}</code>标识。字典由索引（key）和它对应的值value组成，字典是无序的对象集合。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>创建变量时会在内存中开辟一个空间。基于变量的数据类型，解释器会分配指定内存。</p>\n<h2 id=\"python的数据类型\"><a href=\"#python的数据类型\" class=\"headerlink\" title=\"python的数据类型\"></a>python的数据类型</h2><p>python有五个标准的数据类型：</p>\n<ul>\n<li>numbers：数字</li>\n<li>string：字符串</li>\n<li>list：列表</li>\n<li>tuple：元组</li>\n<li>dictionary：字典</li>\n</ul>\n<h4 id=\"numbers\"><a href=\"#numbers\" class=\"headerlink\" title=\"numbers\"></a>numbers</h4><h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p>列表用<code>[]</code>标识。列表是有序的对象集合。</p>\n<h4 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h4><p>元组用<code>()</code>标识，内部元素用<code>,</code>隔开。</p>\n<h4 id=\"dictionary\"><a href=\"#dictionary\" class=\"headerlink\" title=\"dictionary\"></a>dictionary</h4><p>字典用<code>{}</code>标识。字典由索引（key）和它对应的值value组成，字典是无序的对象集合。</p>\n"},{"title":"python函数","date":"2018-03-20T03:48:34.000Z","_content":"\n相关链接：\npython3中文手册：[http://docs.pythontab.com/python/python3.4/](http://docs.pythontab.com/python/python3.4/)\n\n\n## 缺省参数\n调用函数时，缺省参数的值如果没有传入，则被认为是默认值。\n举例：\n```\ndef printme(a=\"aa\"):\n    print (a);\n    return;\n\nprintme();\n\n```\n输出值为：\naa\n\n## 不定长参数\n你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，不定长参数声明时不会命名。\n*args 可变的positional arguments列表；**kwargs可变的keyword arguments列表。\n举例：\n```\ndef printme(*args, **kwargs):\n    for var in args:\n        print (var)\n    for k,v in kwargs.items():\n        print(kwargs)\n    return\n    \nprintme(1,2,3,a1=4)\n```\n输出值为：\n1\n2\n3\n{'a1': 4}\n\n## 参数self\nself代表类的实例。\n```\nclass Test:\n    def prt(self):\n        print(self)\n        print(self.__class__)\nt=Test()\nt.prt()\n```\n输出值：\n<__main__.Test object at 0x1814cec9b0>\n&lt; class '__main__.Test'>\n\n## 构造函数\n\\__init\\__()为类的构造函数或初始化方法。\n\n## 装饰器@\n一个装饰器就是一个语法糖。\n\n```\ndef dec(f):\n    print(\"call for \"+f.__name__+\"()...\")\n    return f\n\n@dec\ndef factorial():\n    return (\"aa\")\n\n\nprint (factorial())\n```\n输出值：\ncall for factorial()...\naa\n\n## python内置函数\n#### classmethod修饰符\nclassmethod修饰符可以来调用类的属性，类的方法，实例化对象等，对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的 cls 参数。\nself一般是在实例方法中使用，而cls则一般在类方法中使用，在静态方法中则不需要使用一个默认参数。\n```\nclass A():\n    bar=1\n    def func1():\n        print(\"foo\")\n    @classmethod\n    def func2(cls):\n        print(\"funct2\")\n        print(cls.bar)\n        \nA.func2()\n```\n输出值：\nfunct2\n1\n*****\n#### open()\nopen()函数用于打开一个文件，创建一个file对象。\n函数语法：\n```\nopen(name[,mode[,buffering]])\n```\n参数说明：\n* name : 包含了你要访问的文件名称的字符串值。\n* mode : mode 决定了打开文件的模式：只读，写入，追加等。这个参数是非强制的，默认文件访问模式为只读(r)。\n* buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。\n\n\n\n\n","source":"_posts/python学习笔记.md","raw":"---\ntitle: python函数\ndate: 2018-03-20 11:48:34\ntags: \n  - 开发\n  - 后端\n  - python\n---\n\n相关链接：\npython3中文手册：[http://docs.pythontab.com/python/python3.4/](http://docs.pythontab.com/python/python3.4/)\n\n\n## 缺省参数\n调用函数时，缺省参数的值如果没有传入，则被认为是默认值。\n举例：\n```\ndef printme(a=\"aa\"):\n    print (a);\n    return;\n\nprintme();\n\n```\n输出值为：\naa\n\n## 不定长参数\n你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，不定长参数声明时不会命名。\n*args 可变的positional arguments列表；**kwargs可变的keyword arguments列表。\n举例：\n```\ndef printme(*args, **kwargs):\n    for var in args:\n        print (var)\n    for k,v in kwargs.items():\n        print(kwargs)\n    return\n    \nprintme(1,2,3,a1=4)\n```\n输出值为：\n1\n2\n3\n{'a1': 4}\n\n## 参数self\nself代表类的实例。\n```\nclass Test:\n    def prt(self):\n        print(self)\n        print(self.__class__)\nt=Test()\nt.prt()\n```\n输出值：\n<__main__.Test object at 0x1814cec9b0>\n&lt; class '__main__.Test'>\n\n## 构造函数\n\\__init\\__()为类的构造函数或初始化方法。\n\n## 装饰器@\n一个装饰器就是一个语法糖。\n\n```\ndef dec(f):\n    print(\"call for \"+f.__name__+\"()...\")\n    return f\n\n@dec\ndef factorial():\n    return (\"aa\")\n\n\nprint (factorial())\n```\n输出值：\ncall for factorial()...\naa\n\n## python内置函数\n#### classmethod修饰符\nclassmethod修饰符可以来调用类的属性，类的方法，实例化对象等，对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的 cls 参数。\nself一般是在实例方法中使用，而cls则一般在类方法中使用，在静态方法中则不需要使用一个默认参数。\n```\nclass A():\n    bar=1\n    def func1():\n        print(\"foo\")\n    @classmethod\n    def func2(cls):\n        print(\"funct2\")\n        print(cls.bar)\n        \nA.func2()\n```\n输出值：\nfunct2\n1\n*****\n#### open()\nopen()函数用于打开一个文件，创建一个file对象。\n函数语法：\n```\nopen(name[,mode[,buffering]])\n```\n参数说明：\n* name : 包含了你要访问的文件名称的字符串值。\n* mode : mode 决定了打开文件的模式：只读，写入，追加等。这个参数是非强制的，默认文件访问模式为只读(r)。\n* buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。\n\n\n\n\n","slug":"python学习笔记","published":1,"updated":"2018-03-30T04:22:21.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxgm2000f1yohn7a3wqoy","content":"<p>相关链接：<br>python3中文手册：<a href=\"http://docs.pythontab.com/python/python3.4/\" target=\"_blank\" rel=\"noopener\">http://docs.pythontab.com/python/python3.4/</a></p>\n<h2 id=\"缺省参数\"><a href=\"#缺省参数\" class=\"headerlink\" title=\"缺省参数\"></a>缺省参数</h2><p>调用函数时，缺省参数的值如果没有传入，则被认为是默认值。<br>举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printme(a=&quot;aa&quot;):</span><br><span class=\"line\">    print (a);</span><br><span class=\"line\">    return;</span><br><span class=\"line\"></span><br><span class=\"line\">printme();</span><br></pre></td></tr></table></figure></p>\n<p>输出值为：<br>aa</p>\n<h2 id=\"不定长参数\"><a href=\"#不定长参数\" class=\"headerlink\" title=\"不定长参数\"></a>不定长参数</h2><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，不定长参数声明时不会命名。<br>*args 可变的positional arguments列表；**kwargs可变的keyword arguments列表。<br>举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printme(*args, **kwargs):</span><br><span class=\"line\">    for var in args:</span><br><span class=\"line\">        print (var)</span><br><span class=\"line\">    for k,v in kwargs.items():</span><br><span class=\"line\">        print(kwargs)</span><br><span class=\"line\">    return</span><br><span class=\"line\">    </span><br><span class=\"line\">printme(1,2,3,a1=4)</span><br></pre></td></tr></table></figure></p>\n<p>输出值为：<br>1<br>2<br>3<br>{‘a1’: 4}</p>\n<h2 id=\"参数self\"><a href=\"#参数self\" class=\"headerlink\" title=\"参数self\"></a>参数self</h2><p>self代表类的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test:</span><br><span class=\"line\">    def prt(self):</span><br><span class=\"line\">        print(self)</span><br><span class=\"line\">        print(self.__class__)</span><br><span class=\"line\">t=Test()</span><br><span class=\"line\">t.prt()</span><br></pre></td></tr></table></figure></p>\n<p>输出值：</p>\n<p>&lt;<strong>main</strong>.Test object at 0x1814cec9b0&gt;<br>&lt; class ‘<strong>main</strong>.Test’&gt;</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>__init__()为类的构造函数或初始化方法。</p>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器@\"></a>装饰器@</h2><p>一个装饰器就是一个语法糖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def dec(f):</span><br><span class=\"line\">    print(&quot;call for &quot;+f.__name__+&quot;()...&quot;)</span><br><span class=\"line\">    return f</span><br><span class=\"line\"></span><br><span class=\"line\">@dec</span><br><span class=\"line\">def factorial():</span><br><span class=\"line\">    return (&quot;aa&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print (factorial())</span><br></pre></td></tr></table></figure>\n<p>输出值：<br>call for factorial()…<br>aa</p>\n<h2 id=\"python内置函数\"><a href=\"#python内置函数\" class=\"headerlink\" title=\"python内置函数\"></a>python内置函数</h2><h4 id=\"classmethod修饰符\"><a href=\"#classmethod修饰符\" class=\"headerlink\" title=\"classmethod修饰符\"></a>classmethod修饰符</h4><p>classmethod修饰符可以来调用类的属性，类的方法，实例化对象等，对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的 cls 参数。<br>self一般是在实例方法中使用，而cls则一般在类方法中使用，在静态方法中则不需要使用一个默认参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A():</span><br><span class=\"line\">    bar=1</span><br><span class=\"line\">    def func1():</span><br><span class=\"line\">        print(&quot;foo&quot;)</span><br><span class=\"line\">    @classmethod</span><br><span class=\"line\">    def func2(cls):</span><br><span class=\"line\">        print(&quot;funct2&quot;)</span><br><span class=\"line\">        print(cls.bar)</span><br><span class=\"line\">        </span><br><span class=\"line\">A.func2()</span><br></pre></td></tr></table></figure></p>\n<p>输出值：<br>funct2<br>1</p>\n<hr>\n<h4 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open()\"></a>open()</h4><p>open()函数用于打开一个文件，创建一个file对象。<br>函数语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(name[,mode[,buffering]])</span><br></pre></td></tr></table></figure></p>\n<p>参数说明：</p>\n<ul>\n<li>name : 包含了你要访问的文件名称的字符串值。</li>\n<li>mode : mode 决定了打开文件的模式：只读，写入，追加等。这个参数是非强制的，默认文件访问模式为只读(r)。</li>\n<li>buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>相关链接：<br>python3中文手册：<a href=\"http://docs.pythontab.com/python/python3.4/\" target=\"_blank\" rel=\"noopener\">http://docs.pythontab.com/python/python3.4/</a></p>\n<h2 id=\"缺省参数\"><a href=\"#缺省参数\" class=\"headerlink\" title=\"缺省参数\"></a>缺省参数</h2><p>调用函数时，缺省参数的值如果没有传入，则被认为是默认值。<br>举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printme(a=&quot;aa&quot;):</span><br><span class=\"line\">    print (a);</span><br><span class=\"line\">    return;</span><br><span class=\"line\"></span><br><span class=\"line\">printme();</span><br></pre></td></tr></table></figure></p>\n<p>输出值为：<br>aa</p>\n<h2 id=\"不定长参数\"><a href=\"#不定长参数\" class=\"headerlink\" title=\"不定长参数\"></a>不定长参数</h2><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，不定长参数声明时不会命名。<br>*args 可变的positional arguments列表；**kwargs可变的keyword arguments列表。<br>举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printme(*args, **kwargs):</span><br><span class=\"line\">    for var in args:</span><br><span class=\"line\">        print (var)</span><br><span class=\"line\">    for k,v in kwargs.items():</span><br><span class=\"line\">        print(kwargs)</span><br><span class=\"line\">    return</span><br><span class=\"line\">    </span><br><span class=\"line\">printme(1,2,3,a1=4)</span><br></pre></td></tr></table></figure></p>\n<p>输出值为：<br>1<br>2<br>3<br>{‘a1’: 4}</p>\n<h2 id=\"参数self\"><a href=\"#参数self\" class=\"headerlink\" title=\"参数self\"></a>参数self</h2><p>self代表类的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test:</span><br><span class=\"line\">    def prt(self):</span><br><span class=\"line\">        print(self)</span><br><span class=\"line\">        print(self.__class__)</span><br><span class=\"line\">t=Test()</span><br><span class=\"line\">t.prt()</span><br></pre></td></tr></table></figure></p>\n<p>输出值：</p>\n<p>&lt;<strong>main</strong>.Test object at 0x1814cec9b0&gt;<br>&lt; class ‘<strong>main</strong>.Test’&gt;</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>__init__()为类的构造函数或初始化方法。</p>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器@\"></a>装饰器@</h2><p>一个装饰器就是一个语法糖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def dec(f):</span><br><span class=\"line\">    print(&quot;call for &quot;+f.__name__+&quot;()...&quot;)</span><br><span class=\"line\">    return f</span><br><span class=\"line\"></span><br><span class=\"line\">@dec</span><br><span class=\"line\">def factorial():</span><br><span class=\"line\">    return (&quot;aa&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print (factorial())</span><br></pre></td></tr></table></figure>\n<p>输出值：<br>call for factorial()…<br>aa</p>\n<h2 id=\"python内置函数\"><a href=\"#python内置函数\" class=\"headerlink\" title=\"python内置函数\"></a>python内置函数</h2><h4 id=\"classmethod修饰符\"><a href=\"#classmethod修饰符\" class=\"headerlink\" title=\"classmethod修饰符\"></a>classmethod修饰符</h4><p>classmethod修饰符可以来调用类的属性，类的方法，实例化对象等，对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的 cls 参数。<br>self一般是在实例方法中使用，而cls则一般在类方法中使用，在静态方法中则不需要使用一个默认参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A():</span><br><span class=\"line\">    bar=1</span><br><span class=\"line\">    def func1():</span><br><span class=\"line\">        print(&quot;foo&quot;)</span><br><span class=\"line\">    @classmethod</span><br><span class=\"line\">    def func2(cls):</span><br><span class=\"line\">        print(&quot;funct2&quot;)</span><br><span class=\"line\">        print(cls.bar)</span><br><span class=\"line\">        </span><br><span class=\"line\">A.func2()</span><br></pre></td></tr></table></figure></p>\n<p>输出值：<br>funct2<br>1</p>\n<hr>\n<h4 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open()\"></a>open()</h4><p>open()函数用于打开一个文件，创建一个file对象。<br>函数语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(name[,mode[,buffering]])</span><br></pre></td></tr></table></figure></p>\n<p>参数说明：</p>\n<ul>\n<li>name : 包含了你要访问的文件名称的字符串值。</li>\n<li>mode : mode 决定了打开文件的模式：只读，写入，追加等。这个参数是非强制的，默认文件访问模式为只读(r)。</li>\n<li>buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</li>\n</ul>\n"},{"title":"后端学习笔记","date":"2018-03-19T07:58:05.000Z","_content":"## 一些概念\n#### 代理\nproxy，也称网络代理，一种网络服务。允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。\n\n![proxy](../img/proxy.jpg)\n\n正向代理的作用：\n* 访问原来无法访问的资源\n* 可以做缓存，加速访问资源\n* 对客户端访问授权，上网进行认证\n* 可以记录用户访问记录（上网行为管理），对外隐藏用户信息\n\n#### 反向代理\nreverse proxy，指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。\n\n反向代理的作用：\n* 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击\n\n*****\n正向代理VS反向代理：\n![proxy](../img/zhengfanxiang.png)\n* 正向代理中，proxy和client同属一个LAN，对server透明；\n* 反向代理中，proxy和server同属一个LAN，对client透明。\n\n#### 代理服务器\nproxy server,提供代理服务的电脑系统或其它类型的网络终端称为代理服务器.\n#### nginx：\n一个高性能的HTTP和反向代理服务器。\n","source":"_posts/后端学习笔记.md","raw":"---\ntitle: 后端学习笔记\ndate: 2018-03-19 15:58:05\ntags:\n    - 后端\n---\n## 一些概念\n#### 代理\nproxy，也称网络代理，一种网络服务。允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。\n\n![proxy](../img/proxy.jpg)\n\n正向代理的作用：\n* 访问原来无法访问的资源\n* 可以做缓存，加速访问资源\n* 对客户端访问授权，上网进行认证\n* 可以记录用户访问记录（上网行为管理），对外隐藏用户信息\n\n#### 反向代理\nreverse proxy，指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。\n\n反向代理的作用：\n* 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击\n\n*****\n正向代理VS反向代理：\n![proxy](../img/zhengfanxiang.png)\n* 正向代理中，proxy和client同属一个LAN，对server透明；\n* 反向代理中，proxy和server同属一个LAN，对client透明。\n\n#### 代理服务器\nproxy server,提供代理服务的电脑系统或其它类型的网络终端称为代理服务器.\n#### nginx：\n一个高性能的HTTP和反向代理服务器。\n","slug":"后端学习笔记","published":1,"updated":"2018-03-29T03:15:48.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxgm6000g1yoh5j8xytnq","content":"<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><h4 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h4><p>proxy，也称网络代理，一种网络服务。允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。</p>\n<p><img src=\"../img/proxy.jpg\" alt=\"proxy\"></p>\n<p>正向代理的作用：</p>\n<ul>\n<li>访问原来无法访问的资源</li>\n<li>可以做缓存，加速访问资源</li>\n<li>对客户端访问授权，上网进行认证</li>\n<li>可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>\n</ul>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>reverse proxy，指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。</p>\n<p>反向代理的作用：</p>\n<ul>\n<li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li>\n</ul>\n<hr>\n<p>正向代理VS反向代理：<br><img src=\"../img/zhengfanxiang.png\" alt=\"proxy\"></p>\n<ul>\n<li>正向代理中，proxy和client同属一个LAN，对server透明；</li>\n<li>反向代理中，proxy和server同属一个LAN，对client透明。</li>\n</ul>\n<h4 id=\"代理服务器\"><a href=\"#代理服务器\" class=\"headerlink\" title=\"代理服务器\"></a>代理服务器</h4><p>proxy server,提供代理服务的电脑系统或其它类型的网络终端称为代理服务器.</p>\n<h4 id=\"nginx：\"><a href=\"#nginx：\" class=\"headerlink\" title=\"nginx：\"></a>nginx：</h4><p>一个高性能的HTTP和反向代理服务器。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><h4 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h4><p>proxy，也称网络代理，一种网络服务。允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。</p>\n<p><img src=\"../img/proxy.jpg\" alt=\"proxy\"></p>\n<p>正向代理的作用：</p>\n<ul>\n<li>访问原来无法访问的资源</li>\n<li>可以做缓存，加速访问资源</li>\n<li>对客户端访问授权，上网进行认证</li>\n<li>可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>\n</ul>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>reverse proxy，指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。</p>\n<p>反向代理的作用：</p>\n<ul>\n<li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li>\n</ul>\n<hr>\n<p>正向代理VS反向代理：<br><img src=\"../img/zhengfanxiang.png\" alt=\"proxy\"></p>\n<ul>\n<li>正向代理中，proxy和client同属一个LAN，对server透明；</li>\n<li>反向代理中，proxy和server同属一个LAN，对client透明。</li>\n</ul>\n<h4 id=\"代理服务器\"><a href=\"#代理服务器\" class=\"headerlink\" title=\"代理服务器\"></a>代理服务器</h4><p>proxy server,提供代理服务的电脑系统或其它类型的网络终端称为代理服务器.</p>\n<h4 id=\"nginx：\"><a href=\"#nginx：\" class=\"headerlink\" title=\"nginx：\"></a>nginx：</h4><p>一个高性能的HTTP和反向代理服务器。</p>\n"},{"title":"前端学习笔记","date":"2018-03-16T04:08:00.000Z","_content":"这是我的前端学习笔记。 \n<!--more--> \n## html学习\n#### html元素\nhtml文档是由html元素组成的。html元素分为：块级元素和内联元素。\n\n\n\n* 块级元素特点：\n1. 总是在新行上开始；\n*****\n* 内联元素特点：\n1. 和其它元素都在一行上；\n*****\n#### html标签\n##### <meta>标签\n**charset属性:**规定html文档的字符编码。\n##### <base>标签\n<base> 标签为页面上的所有链接规定默认地址或默认目标。通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。使用 <base> 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。<base> 标签必须位于 head 元素内部。\n**target属性：**_blank:在新窗口打开链接；_self:在当前窗口打开链接；\n##### <link>标签\n<link> 标签定义文档与外部资源的关系,最常见的用途是链接样式表。\n**href属性:** 规定被链接文档的位置。\n**rel:**规定当前文档与被链接文档之前的关系。\n\n#### 小工具\n* html转换为pug: [http://html2jade.vida.io/](http://html2jade.vida.io/)\n*****\n## CSS学习\n*****\n## DOM\n文档对象模型，Document Object Model，主要用于对HTML和XML文档内容进行操作。\n\n## JS学习\n\n#### 运算符优先级\n下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。\n\n| 运算符\t                                | 描述                                 |\n|-|-|\n| . [] ()\t                        | 字段访问、数组下标、函数调用以及表达式分组    |\n| ++ -- - ~ ! delete new typeof void\t| 一元运算符、返回数据类型、对象创建、未定义值  |\n| * / %\t                                | 乘法、除法、取模                        |\n| + - +\t                                | 加法、减法、字符串连接                   |\n| << >> >>>\t                        | 移位                                  |\n| < <= > >= instanceof\t                | 小于、小于等于、大于、大于等于、instanceof   |\n| == != === !==\t                        | 等于、不等于、严格相等、非严格相等           |\n| &\t                                | 按位与                                 |\n| ^\t                                | 按位异或                               |  \n| &#124;\t                        | 按位或                                 |\n| &&\t                                | 逻辑与                                 |\n| &#124;&#124;\t                        | 逻辑或                                 |\n| ?:\t                                | 条件                                   |\n| = oP=\t                                | 赋值、运算赋值                           |\n| ,\t                                | 多重求值                                |","source":"_posts/前端学习笔记.md","raw":"---\ntitle: 前端学习笔记\ndate: 2018-03-16 12:08:00\ntags: \n   - 开发\n   - 前端\n---\n这是我的前端学习笔记。 \n<!--more--> \n## html学习\n#### html元素\nhtml文档是由html元素组成的。html元素分为：块级元素和内联元素。\n\n\n\n* 块级元素特点：\n1. 总是在新行上开始；\n*****\n* 内联元素特点：\n1. 和其它元素都在一行上；\n*****\n#### html标签\n##### <meta>标签\n**charset属性:**规定html文档的字符编码。\n##### <base>标签\n<base> 标签为页面上的所有链接规定默认地址或默认目标。通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。使用 <base> 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。<base> 标签必须位于 head 元素内部。\n**target属性：**_blank:在新窗口打开链接；_self:在当前窗口打开链接；\n##### <link>标签\n<link> 标签定义文档与外部资源的关系,最常见的用途是链接样式表。\n**href属性:** 规定被链接文档的位置。\n**rel:**规定当前文档与被链接文档之前的关系。\n\n#### 小工具\n* html转换为pug: [http://html2jade.vida.io/](http://html2jade.vida.io/)\n*****\n## CSS学习\n*****\n## DOM\n文档对象模型，Document Object Model，主要用于对HTML和XML文档内容进行操作。\n\n## JS学习\n\n#### 运算符优先级\n下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。\n\n| 运算符\t                                | 描述                                 |\n|-|-|\n| . [] ()\t                        | 字段访问、数组下标、函数调用以及表达式分组    |\n| ++ -- - ~ ! delete new typeof void\t| 一元运算符、返回数据类型、对象创建、未定义值  |\n| * / %\t                                | 乘法、除法、取模                        |\n| + - +\t                                | 加法、减法、字符串连接                   |\n| << >> >>>\t                        | 移位                                  |\n| < <= > >= instanceof\t                | 小于、小于等于、大于、大于等于、instanceof   |\n| == != === !==\t                        | 等于、不等于、严格相等、非严格相等           |\n| &\t                                | 按位与                                 |\n| ^\t                                | 按位异或                               |  \n| &#124;\t                        | 按位或                                 |\n| &&\t                                | 逻辑与                                 |\n| &#124;&#124;\t                        | 逻辑或                                 |\n| ?:\t                                | 条件                                   |\n| = oP=\t                                | 赋值、运算赋值                           |\n| ,\t                                | 多重求值                                |","slug":"前端学习笔记","published":1,"updated":"2018-03-29T02:32:55.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxgm8000i1yoh2iircn4t","content":"<p>这是我的前端学习笔记。<br><a id=\"more\"></a> </p>\n<h2 id=\"html学习\"><a href=\"#html学习\" class=\"headerlink\" title=\"html学习\"></a>html学习</h2><h4 id=\"html元素\"><a href=\"#html元素\" class=\"headerlink\" title=\"html元素\"></a>html元素</h4><p>html文档是由html元素组成的。html元素分为：块级元素和内联元素。</p>\n<ul>\n<li>块级元素特点：</li>\n</ul>\n<ol>\n<li>总是在新行上开始；</li>\n</ol>\n<hr>\n<ul>\n<li>内联元素特点：</li>\n</ul>\n<ol>\n<li>和其它元素都在一行上；</li>\n</ol>\n<hr>\n<h4 id=\"html标签\"><a href=\"#html标签\" class=\"headerlink\" title=\"html标签\"></a>html标签</h4><h5 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a><meta>标签</h5><p><strong>charset属性:</strong>规定html文档的字符编码。</p>\n<h5 id=\"标签-1\"><a href=\"#标签-1\" class=\"headerlink\" title=\"标签\"></a><base>标签</h5><p><base> 标签为页面上的所有链接规定默认地址或默认目标。通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。使用 <base> 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。<base> 标签必须位于 head 元素内部。<br><strong>target属性：</strong>_blank:在新窗口打开链接；_self:在当前窗口打开链接；</p>\n<h5 id=\"标签-2\"><a href=\"#标签-2\" class=\"headerlink\" title=\"标签\"></a><link>标签</h5><p><link> 标签定义文档与外部资源的关系,最常见的用途是链接样式表。<br><strong>href属性:</strong> 规定被链接文档的位置。<br><strong>rel:</strong>规定当前文档与被链接文档之前的关系。</p>\n<h4 id=\"小工具\"><a href=\"#小工具\" class=\"headerlink\" title=\"小工具\"></a>小工具</h4><ul>\n<li>html转换为pug: <a href=\"http://html2jade.vida.io/\" target=\"_blank\" rel=\"noopener\">http://html2jade.vida.io/</a></li>\n</ul>\n<hr>\n<h2 id=\"CSS学习\"><a href=\"#CSS学习\" class=\"headerlink\" title=\"CSS学习\"></a>CSS学习</h2><hr>\n<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h2><p>文档对象模型，Document Object Model，主要用于对HTML和XML文档内容进行操作。</p>\n<h2 id=\"JS学习\"><a href=\"#JS学习\" class=\"headerlink\" title=\"JS学习\"></a>JS学习</h2><h4 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h4><p>下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>. [] ()</td>\n<td>字段访问、数组下标、函数调用以及表达式分组</td>\n</tr>\n<tr>\n<td>++ – - ~ ! delete new typeof void</td>\n<td>一元运算符、返回数据类型、对象创建、未定义值</td>\n</tr>\n<tr>\n<td>* / %</td>\n<td>乘法、除法、取模</td>\n</tr>\n<tr>\n<td>+ - +</td>\n<td>加法、减法、字符串连接</td>\n</tr>\n<tr>\n<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>\n<td>移位</td>\n</tr>\n<tr>\n<td>&lt; &lt;= &gt; &gt;= instanceof</td>\n<td>小于、小于等于、大于、大于等于、instanceof</td>\n</tr>\n<tr>\n<td>== != === !==</td>\n<td>等于、不等于、严格相等、非严格相等</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>按位与</td>\n</tr>\n<tr>\n<td>^</td>\n<td>按位异或</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>按位或</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td>?:</td>\n<td>条件</td>\n</tr>\n<tr>\n<td>= oP=</td>\n<td>赋值、运算赋值</td>\n</tr>\n<tr>\n<td>,</td>\n<td>多重求值</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>这是我的前端学习笔记。<br>","more":"</p>\n<h2 id=\"html学习\"><a href=\"#html学习\" class=\"headerlink\" title=\"html学习\"></a>html学习</h2><h4 id=\"html元素\"><a href=\"#html元素\" class=\"headerlink\" title=\"html元素\"></a>html元素</h4><p>html文档是由html元素组成的。html元素分为：块级元素和内联元素。</p>\n<ul>\n<li>块级元素特点：</li>\n</ul>\n<ol>\n<li>总是在新行上开始；</li>\n</ol>\n<hr>\n<ul>\n<li>内联元素特点：</li>\n</ul>\n<ol>\n<li>和其它元素都在一行上；</li>\n</ol>\n<hr>\n<h4 id=\"html标签\"><a href=\"#html标签\" class=\"headerlink\" title=\"html标签\"></a>html标签</h4><h5 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a><meta>标签</h5><p><strong>charset属性:</strong>规定html文档的字符编码。</p>\n<h5 id=\"标签-1\"><a href=\"#标签-1\" class=\"headerlink\" title=\"标签\"></a><base>标签</h5><p><base> 标签为页面上的所有链接规定默认地址或默认目标。通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。使用 <base> 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。<base> 标签必须位于 head 元素内部。<br><strong>target属性：</strong>_blank:在新窗口打开链接；_self:在当前窗口打开链接；</p>\n<h5 id=\"标签-2\"><a href=\"#标签-2\" class=\"headerlink\" title=\"标签\"></a><link>标签</h5><p><link> 标签定义文档与外部资源的关系,最常见的用途是链接样式表。<br><strong>href属性:</strong> 规定被链接文档的位置。<br><strong>rel:</strong>规定当前文档与被链接文档之前的关系。</p>\n<h4 id=\"小工具\"><a href=\"#小工具\" class=\"headerlink\" title=\"小工具\"></a>小工具</h4><ul>\n<li>html转换为pug: <a href=\"http://html2jade.vida.io/\" target=\"_blank\" rel=\"noopener\">http://html2jade.vida.io/</a></li>\n</ul>\n<hr>\n<h2 id=\"CSS学习\"><a href=\"#CSS学习\" class=\"headerlink\" title=\"CSS学习\"></a>CSS学习</h2><hr>\n<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h2><p>文档对象模型，Document Object Model，主要用于对HTML和XML文档内容进行操作。</p>\n<h2 id=\"JS学习\"><a href=\"#JS学习\" class=\"headerlink\" title=\"JS学习\"></a>JS学习</h2><h4 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h4><p>下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>. [] ()</td>\n<td>字段访问、数组下标、函数调用以及表达式分组</td>\n</tr>\n<tr>\n<td>++ – - ~ ! delete new typeof void</td>\n<td>一元运算符、返回数据类型、对象创建、未定义值</td>\n</tr>\n<tr>\n<td>* / %</td>\n<td>乘法、除法、取模</td>\n</tr>\n<tr>\n<td>+ - +</td>\n<td>加法、减法、字符串连接</td>\n</tr>\n<tr>\n<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>\n<td>移位</td>\n</tr>\n<tr>\n<td>&lt; &lt;= &gt; &gt;= instanceof</td>\n<td>小于、小于等于、大于、大于等于、instanceof</td>\n</tr>\n<tr>\n<td>== != === !==</td>\n<td>等于、不等于、严格相等、非严格相等</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>按位与</td>\n</tr>\n<tr>\n<td>^</td>\n<td>按位异或</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>按位或</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td>?:</td>\n<td>条件</td>\n</tr>\n<tr>\n<td>= oP=</td>\n<td>赋值、运算赋值</td>\n</tr>\n<tr>\n<td>,</td>\n<td>多重求值</td>\n</tr>\n</tbody>\n</table>"},{"title":"python异常处理","date":"2018-03-30T03:35:06.000Z","_content":"\n## python标准异常\n|异常名称\t|描述|\n|-|-|\n|BaseException\t|所有异常的基类|\n|SystemExit\t|解释器请求退出|\n|KeyboardInterrupt\t|用户中断执行(通常是输入^C)|\n|Exception\t|常规错误的基类|\n|StopIteration\t|迭代器没有更多的值|\n|GeneratorExit\t|生成器(generator)发生异常来通知退出|\n|StandardError\t|所有的内建标准异常的基类|\n|ArithmeticError\t|所有数值计算错误的基类|\n|FloatingPointError\t|浮点计算错误|\n|OverflowError\t|数值运算超出最大限制|\n|ZeroDivisionError\t|除(或取模)零 (所有数据类型)|\n|AssertionError\t|断言语句失败|\n|AttributeError\t|对象没有这个属性|\n|EOFError\t|没有内建输入,到达EOF 标记|\n|EnvironmentError\t|操作系统错误的基类|\n|IOError\t|输入/输出操作失败|\n|OSError\t|操作系统错误|\n|WindowsError\t|系统调用失败|\n|ImportError\t|导入模块/对象失败|\n|LookupError\t|无效数据查询的基类|\n|IndexError\t|序列中没有此索引(index)|\n|KeyError\t|映射中没有这个键|\n|MemoryError\t|内存溢出错误(对于Python 解释器不是致命的)|\n|NameError\t|未声明/初始化对象 (没有属性)|\n|UnboundLocalError\t|访问未初始化的本地变量|\n|ReferenceError\t|弱引用(Weak reference)试图访问已经垃圾回收了的对象|\n|RuntimeError\t|一般的运行时错误|\n|NotImplementedError\t|尚未实现的方法|\n|SyntaxError\t|Python 语法错误|\n|IndentationError\t|缩进错误|\n|TabError\t|Tab 和空格混用|\n|SystemError\t|一般的解释器系统错误|\n|TypeError\t|对类型无效的操作|\n|ValueError\t|传入无效的参数|\n|UnicodeError\t|Unicode 相关的错误|\n|UnicodeDecodeError\t|Unicode 解码时的错误|\n|UnicodeEncodeError\t|Unicode 编码时错误|\n|UnicodeTranslateError\t|Unicode 转换时错误|\n|Warning\t|警告的基类|\n|DeprecationWarning\t|关于被弃用的特征的警告|\n|FutureWarning\t|关于构造将来语义会有改变的警告|\n|OverflowWarning\t|旧的关于自动提升为长整型(long)的警告|\n|PendingDeprecationWarning\t|关于特性将会被废弃的警告|\n|RuntimeWarning\t|可疑的运行时行为(runtime behavior)的警告|\n|SyntaxWarning\t|可疑的语法的警告|\n|UserWarning\t|用户代码生成的警告|\n\n","source":"_posts/python异常处理.md","raw":"---\ntitle: python异常处理\ndate: 2018-03-30 11:35:06\ntags:\n    - 开发\n    - 后端\n    - python\n---\n\n## python标准异常\n|异常名称\t|描述|\n|-|-|\n|BaseException\t|所有异常的基类|\n|SystemExit\t|解释器请求退出|\n|KeyboardInterrupt\t|用户中断执行(通常是输入^C)|\n|Exception\t|常规错误的基类|\n|StopIteration\t|迭代器没有更多的值|\n|GeneratorExit\t|生成器(generator)发生异常来通知退出|\n|StandardError\t|所有的内建标准异常的基类|\n|ArithmeticError\t|所有数值计算错误的基类|\n|FloatingPointError\t|浮点计算错误|\n|OverflowError\t|数值运算超出最大限制|\n|ZeroDivisionError\t|除(或取模)零 (所有数据类型)|\n|AssertionError\t|断言语句失败|\n|AttributeError\t|对象没有这个属性|\n|EOFError\t|没有内建输入,到达EOF 标记|\n|EnvironmentError\t|操作系统错误的基类|\n|IOError\t|输入/输出操作失败|\n|OSError\t|操作系统错误|\n|WindowsError\t|系统调用失败|\n|ImportError\t|导入模块/对象失败|\n|LookupError\t|无效数据查询的基类|\n|IndexError\t|序列中没有此索引(index)|\n|KeyError\t|映射中没有这个键|\n|MemoryError\t|内存溢出错误(对于Python 解释器不是致命的)|\n|NameError\t|未声明/初始化对象 (没有属性)|\n|UnboundLocalError\t|访问未初始化的本地变量|\n|ReferenceError\t|弱引用(Weak reference)试图访问已经垃圾回收了的对象|\n|RuntimeError\t|一般的运行时错误|\n|NotImplementedError\t|尚未实现的方法|\n|SyntaxError\t|Python 语法错误|\n|IndentationError\t|缩进错误|\n|TabError\t|Tab 和空格混用|\n|SystemError\t|一般的解释器系统错误|\n|TypeError\t|对类型无效的操作|\n|ValueError\t|传入无效的参数|\n|UnicodeError\t|Unicode 相关的错误|\n|UnicodeDecodeError\t|Unicode 解码时的错误|\n|UnicodeEncodeError\t|Unicode 编码时错误|\n|UnicodeTranslateError\t|Unicode 转换时错误|\n|Warning\t|警告的基类|\n|DeprecationWarning\t|关于被弃用的特征的警告|\n|FutureWarning\t|关于构造将来语义会有改变的警告|\n|OverflowWarning\t|旧的关于自动提升为长整型(long)的警告|\n|PendingDeprecationWarning\t|关于特性将会被废弃的警告|\n|RuntimeWarning\t|可疑的运行时行为(runtime behavior)的警告|\n|SyntaxWarning\t|可疑的语法的警告|\n|UserWarning\t|用户代码生成的警告|\n\n","slug":"python异常处理","published":1,"updated":"2018-03-30T03:41:19.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxgm9000k1yohwxffxlxd","content":"<h2 id=\"python标准异常\"><a href=\"#python标准异常\" class=\"headerlink\" title=\"python标准异常\"></a>python标准异常</h2><table>\n<thead>\n<tr>\n<th>异常名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BaseException</td>\n<td>所有异常的基类</td>\n</tr>\n<tr>\n<td>SystemExit</td>\n<td>解释器请求退出</td>\n</tr>\n<tr>\n<td>KeyboardInterrupt</td>\n<td>用户中断执行(通常是输入^C)</td>\n</tr>\n<tr>\n<td>Exception</td>\n<td>常规错误的基类</td>\n</tr>\n<tr>\n<td>StopIteration</td>\n<td>迭代器没有更多的值</td>\n</tr>\n<tr>\n<td>GeneratorExit</td>\n<td>生成器(generator)发生异常来通知退出</td>\n</tr>\n<tr>\n<td>StandardError</td>\n<td>所有的内建标准异常的基类</td>\n</tr>\n<tr>\n<td>ArithmeticError</td>\n<td>所有数值计算错误的基类</td>\n</tr>\n<tr>\n<td>FloatingPointError</td>\n<td>浮点计算错误</td>\n</tr>\n<tr>\n<td>OverflowError</td>\n<td>数值运算超出最大限制</td>\n</tr>\n<tr>\n<td>ZeroDivisionError</td>\n<td>除(或取模)零 (所有数据类型)</td>\n</tr>\n<tr>\n<td>AssertionError</td>\n<td>断言语句失败</td>\n</tr>\n<tr>\n<td>AttributeError</td>\n<td>对象没有这个属性</td>\n</tr>\n<tr>\n<td>EOFError</td>\n<td>没有内建输入,到达EOF 标记</td>\n</tr>\n<tr>\n<td>EnvironmentError</td>\n<td>操作系统错误的基类</td>\n</tr>\n<tr>\n<td>IOError</td>\n<td>输入/输出操作失败</td>\n</tr>\n<tr>\n<td>OSError</td>\n<td>操作系统错误</td>\n</tr>\n<tr>\n<td>WindowsError</td>\n<td>系统调用失败</td>\n</tr>\n<tr>\n<td>ImportError</td>\n<td>导入模块/对象失败</td>\n</tr>\n<tr>\n<td>LookupError</td>\n<td>无效数据查询的基类</td>\n</tr>\n<tr>\n<td>IndexError</td>\n<td>序列中没有此索引(index)</td>\n</tr>\n<tr>\n<td>KeyError</td>\n<td>映射中没有这个键</td>\n</tr>\n<tr>\n<td>MemoryError</td>\n<td>内存溢出错误(对于Python 解释器不是致命的)</td>\n</tr>\n<tr>\n<td>NameError</td>\n<td>未声明/初始化对象 (没有属性)</td>\n</tr>\n<tr>\n<td>UnboundLocalError</td>\n<td>访问未初始化的本地变量</td>\n</tr>\n<tr>\n<td>ReferenceError</td>\n<td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>\n</tr>\n<tr>\n<td>RuntimeError</td>\n<td>一般的运行时错误</td>\n</tr>\n<tr>\n<td>NotImplementedError</td>\n<td>尚未实现的方法</td>\n</tr>\n<tr>\n<td>SyntaxError</td>\n<td>Python 语法错误</td>\n</tr>\n<tr>\n<td>IndentationError</td>\n<td>缩进错误</td>\n</tr>\n<tr>\n<td>TabError</td>\n<td>Tab 和空格混用</td>\n</tr>\n<tr>\n<td>SystemError</td>\n<td>一般的解释器系统错误</td>\n</tr>\n<tr>\n<td>TypeError</td>\n<td>对类型无效的操作</td>\n</tr>\n<tr>\n<td>ValueError</td>\n<td>传入无效的参数</td>\n</tr>\n<tr>\n<td>UnicodeError</td>\n<td>Unicode 相关的错误</td>\n</tr>\n<tr>\n<td>UnicodeDecodeError</td>\n<td>Unicode 解码时的错误</td>\n</tr>\n<tr>\n<td>UnicodeEncodeError</td>\n<td>Unicode 编码时错误</td>\n</tr>\n<tr>\n<td>UnicodeTranslateError</td>\n<td>Unicode 转换时错误</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>警告的基类</td>\n</tr>\n<tr>\n<td>DeprecationWarning</td>\n<td>关于被弃用的特征的警告</td>\n</tr>\n<tr>\n<td>FutureWarning</td>\n<td>关于构造将来语义会有改变的警告</td>\n</tr>\n<tr>\n<td>OverflowWarning</td>\n<td>旧的关于自动提升为长整型(long)的警告</td>\n</tr>\n<tr>\n<td>PendingDeprecationWarning</td>\n<td>关于特性将会被废弃的警告</td>\n</tr>\n<tr>\n<td>RuntimeWarning</td>\n<td>可疑的运行时行为(runtime behavior)的警告</td>\n</tr>\n<tr>\n<td>SyntaxWarning</td>\n<td>可疑的语法的警告</td>\n</tr>\n<tr>\n<td>UserWarning</td>\n<td>用户代码生成的警告</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"python标准异常\"><a href=\"#python标准异常\" class=\"headerlink\" title=\"python标准异常\"></a>python标准异常</h2><table>\n<thead>\n<tr>\n<th>异常名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BaseException</td>\n<td>所有异常的基类</td>\n</tr>\n<tr>\n<td>SystemExit</td>\n<td>解释器请求退出</td>\n</tr>\n<tr>\n<td>KeyboardInterrupt</td>\n<td>用户中断执行(通常是输入^C)</td>\n</tr>\n<tr>\n<td>Exception</td>\n<td>常规错误的基类</td>\n</tr>\n<tr>\n<td>StopIteration</td>\n<td>迭代器没有更多的值</td>\n</tr>\n<tr>\n<td>GeneratorExit</td>\n<td>生成器(generator)发生异常来通知退出</td>\n</tr>\n<tr>\n<td>StandardError</td>\n<td>所有的内建标准异常的基类</td>\n</tr>\n<tr>\n<td>ArithmeticError</td>\n<td>所有数值计算错误的基类</td>\n</tr>\n<tr>\n<td>FloatingPointError</td>\n<td>浮点计算错误</td>\n</tr>\n<tr>\n<td>OverflowError</td>\n<td>数值运算超出最大限制</td>\n</tr>\n<tr>\n<td>ZeroDivisionError</td>\n<td>除(或取模)零 (所有数据类型)</td>\n</tr>\n<tr>\n<td>AssertionError</td>\n<td>断言语句失败</td>\n</tr>\n<tr>\n<td>AttributeError</td>\n<td>对象没有这个属性</td>\n</tr>\n<tr>\n<td>EOFError</td>\n<td>没有内建输入,到达EOF 标记</td>\n</tr>\n<tr>\n<td>EnvironmentError</td>\n<td>操作系统错误的基类</td>\n</tr>\n<tr>\n<td>IOError</td>\n<td>输入/输出操作失败</td>\n</tr>\n<tr>\n<td>OSError</td>\n<td>操作系统错误</td>\n</tr>\n<tr>\n<td>WindowsError</td>\n<td>系统调用失败</td>\n</tr>\n<tr>\n<td>ImportError</td>\n<td>导入模块/对象失败</td>\n</tr>\n<tr>\n<td>LookupError</td>\n<td>无效数据查询的基类</td>\n</tr>\n<tr>\n<td>IndexError</td>\n<td>序列中没有此索引(index)</td>\n</tr>\n<tr>\n<td>KeyError</td>\n<td>映射中没有这个键</td>\n</tr>\n<tr>\n<td>MemoryError</td>\n<td>内存溢出错误(对于Python 解释器不是致命的)</td>\n</tr>\n<tr>\n<td>NameError</td>\n<td>未声明/初始化对象 (没有属性)</td>\n</tr>\n<tr>\n<td>UnboundLocalError</td>\n<td>访问未初始化的本地变量</td>\n</tr>\n<tr>\n<td>ReferenceError</td>\n<td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>\n</tr>\n<tr>\n<td>RuntimeError</td>\n<td>一般的运行时错误</td>\n</tr>\n<tr>\n<td>NotImplementedError</td>\n<td>尚未实现的方法</td>\n</tr>\n<tr>\n<td>SyntaxError</td>\n<td>Python 语法错误</td>\n</tr>\n<tr>\n<td>IndentationError</td>\n<td>缩进错误</td>\n</tr>\n<tr>\n<td>TabError</td>\n<td>Tab 和空格混用</td>\n</tr>\n<tr>\n<td>SystemError</td>\n<td>一般的解释器系统错误</td>\n</tr>\n<tr>\n<td>TypeError</td>\n<td>对类型无效的操作</td>\n</tr>\n<tr>\n<td>ValueError</td>\n<td>传入无效的参数</td>\n</tr>\n<tr>\n<td>UnicodeError</td>\n<td>Unicode 相关的错误</td>\n</tr>\n<tr>\n<td>UnicodeDecodeError</td>\n<td>Unicode 解码时的错误</td>\n</tr>\n<tr>\n<td>UnicodeEncodeError</td>\n<td>Unicode 编码时错误</td>\n</tr>\n<tr>\n<td>UnicodeTranslateError</td>\n<td>Unicode 转换时错误</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>警告的基类</td>\n</tr>\n<tr>\n<td>DeprecationWarning</td>\n<td>关于被弃用的特征的警告</td>\n</tr>\n<tr>\n<td>FutureWarning</td>\n<td>关于构造将来语义会有改变的警告</td>\n</tr>\n<tr>\n<td>OverflowWarning</td>\n<td>旧的关于自动提升为长整型(long)的警告</td>\n</tr>\n<tr>\n<td>PendingDeprecationWarning</td>\n<td>关于特性将会被废弃的警告</td>\n</tr>\n<tr>\n<td>RuntimeWarning</td>\n<td>可疑的运行时行为(runtime behavior)的警告</td>\n</tr>\n<tr>\n<td>SyntaxWarning</td>\n<td>可疑的语法的警告</td>\n</tr>\n<tr>\n<td>UserWarning</td>\n<td>用户代码生成的警告</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"网络技术学习笔记","date":"2018-03-20T09:44:18.000Z","_content":"\n## TCP/IP协议端口\n端口号的范围从0到65535。\n*****\n\n#### 端口分类：\n按端口号划分：\n##### 公认端口：\n0～1023，它们紧密帮定于一些服务，通常这些端口的通讯表明了某种服务的协议。\n* 80端口：HTTP通信；\n* 21端口：FTP服务；\n* 23端口：Telnet服务；\n* 25端口：SMTP服务；\n* 135端口：RPC服务；\n\n##### 注册端口：\n1024～49151，它们松散的绑定于一些服务；\n##### 动态和私有端口：\n49152～65535，理论上，不应为服务分配这些端口，通常机器从1024开始分配动态端口。\n*****\n*****\n按协议类型划分：\n##### TCP端口：\n即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP的21端口，Telnet的23端口，SMTP的25端口，HTTP的80端口。\n##### UDP端口：\n即用户数据报协议端口，无需在客户端和服务器端建立连接，安全性得不到保障。常见的DNS的53端口，SNMP（简单网络管理协议）的161端口，QQ使用的8000和4000端口。\n\n*****\n## TCP连接\n在TCP/IP协议栈中，源端口号和目的端口号分别与源IP地址和目的IP地址组成套接字（socket），唯一的确定一条TCP连接。\n*****\n网络层次：\n![](../img/wangluocengci.png)\n*****\n## UDP\nuser datagram protocol，用户数据报协议，是一种无连接的传输层协议。\n*****\n## socket\n网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。\nsocket是对TCP协议的封装。","source":"_posts/网络技术学习笔记.md","raw":"---\ntitle: 网络技术学习笔记\ndate: 2018-03-20 17:44:18\ntags:\n---\n\n## TCP/IP协议端口\n端口号的范围从0到65535。\n*****\n\n#### 端口分类：\n按端口号划分：\n##### 公认端口：\n0～1023，它们紧密帮定于一些服务，通常这些端口的通讯表明了某种服务的协议。\n* 80端口：HTTP通信；\n* 21端口：FTP服务；\n* 23端口：Telnet服务；\n* 25端口：SMTP服务；\n* 135端口：RPC服务；\n\n##### 注册端口：\n1024～49151，它们松散的绑定于一些服务；\n##### 动态和私有端口：\n49152～65535，理论上，不应为服务分配这些端口，通常机器从1024开始分配动态端口。\n*****\n*****\n按协议类型划分：\n##### TCP端口：\n即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP的21端口，Telnet的23端口，SMTP的25端口，HTTP的80端口。\n##### UDP端口：\n即用户数据报协议端口，无需在客户端和服务器端建立连接，安全性得不到保障。常见的DNS的53端口，SNMP（简单网络管理协议）的161端口，QQ使用的8000和4000端口。\n\n*****\n## TCP连接\n在TCP/IP协议栈中，源端口号和目的端口号分别与源IP地址和目的IP地址组成套接字（socket），唯一的确定一条TCP连接。\n*****\n网络层次：\n![](../img/wangluocengci.png)\n*****\n## UDP\nuser datagram protocol，用户数据报协议，是一种无连接的传输层协议。\n*****\n## socket\n网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。\nsocket是对TCP协议的封装。","slug":"网络技术学习笔记","published":1,"updated":"2018-03-21T03:35:46.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxgmb000n1yohpclwckfr","content":"<h2 id=\"TCP-IP协议端口\"><a href=\"#TCP-IP协议端口\" class=\"headerlink\" title=\"TCP/IP协议端口\"></a>TCP/IP协议端口</h2><p>端口号的范围从0到65535。</p>\n<hr>\n<h4 id=\"端口分类：\"><a href=\"#端口分类：\" class=\"headerlink\" title=\"端口分类：\"></a>端口分类：</h4><p>按端口号划分：</p>\n<h5 id=\"公认端口：\"><a href=\"#公认端口：\" class=\"headerlink\" title=\"公认端口：\"></a>公认端口：</h5><p>0～1023，它们紧密帮定于一些服务，通常这些端口的通讯表明了某种服务的协议。</p>\n<ul>\n<li>80端口：HTTP通信；</li>\n<li>21端口：FTP服务；</li>\n<li>23端口：Telnet服务；</li>\n<li>25端口：SMTP服务；</li>\n<li>135端口：RPC服务；</li>\n</ul>\n<h5 id=\"注册端口：\"><a href=\"#注册端口：\" class=\"headerlink\" title=\"注册端口：\"></a>注册端口：</h5><p>1024～49151，它们松散的绑定于一些服务；</p>\n<h5 id=\"动态和私有端口：\"><a href=\"#动态和私有端口：\" class=\"headerlink\" title=\"动态和私有端口：\"></a>动态和私有端口：</h5><p>49152～65535，理论上，不应为服务分配这些端口，通常机器从1024开始分配动态端口。</p>\n<hr>\n<hr>\n<p>按协议类型划分：</p>\n<h5 id=\"TCP端口：\"><a href=\"#TCP端口：\" class=\"headerlink\" title=\"TCP端口：\"></a>TCP端口：</h5><p>即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP的21端口，Telnet的23端口，SMTP的25端口，HTTP的80端口。</p>\n<h5 id=\"UDP端口：\"><a href=\"#UDP端口：\" class=\"headerlink\" title=\"UDP端口：\"></a>UDP端口：</h5><p>即用户数据报协议端口，无需在客户端和服务器端建立连接，安全性得不到保障。常见的DNS的53端口，SNMP（简单网络管理协议）的161端口，QQ使用的8000和4000端口。</p>\n<hr>\n<h2 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h2><p>在TCP/IP协议栈中，源端口号和目的端口号分别与源IP地址和目的IP地址组成套接字（socket），唯一的确定一条TCP连接。</p>\n<hr>\n<p>网络层次：<br><img src=\"../img/wangluocengci.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>user datagram protocol，用户数据报协议，是一种无连接的传输层协议。</p>\n<hr>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。<br>socket是对TCP协议的封装。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TCP-IP协议端口\"><a href=\"#TCP-IP协议端口\" class=\"headerlink\" title=\"TCP/IP协议端口\"></a>TCP/IP协议端口</h2><p>端口号的范围从0到65535。</p>\n<hr>\n<h4 id=\"端口分类：\"><a href=\"#端口分类：\" class=\"headerlink\" title=\"端口分类：\"></a>端口分类：</h4><p>按端口号划分：</p>\n<h5 id=\"公认端口：\"><a href=\"#公认端口：\" class=\"headerlink\" title=\"公认端口：\"></a>公认端口：</h5><p>0～1023，它们紧密帮定于一些服务，通常这些端口的通讯表明了某种服务的协议。</p>\n<ul>\n<li>80端口：HTTP通信；</li>\n<li>21端口：FTP服务；</li>\n<li>23端口：Telnet服务；</li>\n<li>25端口：SMTP服务；</li>\n<li>135端口：RPC服务；</li>\n</ul>\n<h5 id=\"注册端口：\"><a href=\"#注册端口：\" class=\"headerlink\" title=\"注册端口：\"></a>注册端口：</h5><p>1024～49151，它们松散的绑定于一些服务；</p>\n<h5 id=\"动态和私有端口：\"><a href=\"#动态和私有端口：\" class=\"headerlink\" title=\"动态和私有端口：\"></a>动态和私有端口：</h5><p>49152～65535，理论上，不应为服务分配这些端口，通常机器从1024开始分配动态端口。</p>\n<hr>\n<hr>\n<p>按协议类型划分：</p>\n<h5 id=\"TCP端口：\"><a href=\"#TCP端口：\" class=\"headerlink\" title=\"TCP端口：\"></a>TCP端口：</h5><p>即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP的21端口，Telnet的23端口，SMTP的25端口，HTTP的80端口。</p>\n<h5 id=\"UDP端口：\"><a href=\"#UDP端口：\" class=\"headerlink\" title=\"UDP端口：\"></a>UDP端口：</h5><p>即用户数据报协议端口，无需在客户端和服务器端建立连接，安全性得不到保障。常见的DNS的53端口，SNMP（简单网络管理协议）的161端口，QQ使用的8000和4000端口。</p>\n<hr>\n<h2 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h2><p>在TCP/IP协议栈中，源端口号和目的端口号分别与源IP地址和目的IP地址组成套接字（socket），唯一的确定一条TCP连接。</p>\n<hr>\n<p>网络层次：<br><img src=\"../img/wangluocengci.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>user datagram protocol，用户数据报协议，是一种无连接的传输层协议。</p>\n<hr>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。<br>socket是对TCP协议的封装。</p>\n"},{"title":"股票学习笔记","date":"2018-03-21T05:39:21.000Z","_content":"\n## 筹码稳定度","source":"_posts/股票学习笔记.md","raw":"---\ntitle: 股票学习笔记\ndate: 2018-03-21 13:39:21\ntags:\n   - 股票\n---\n\n## 筹码稳定度","slug":"股票学习笔记","published":1,"updated":"2018-03-28T07:39:44.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqmxgmd000o1yoh2nt2sn90","content":"<h2 id=\"筹码稳定度\"><a href=\"#筹码稳定度\" class=\"headerlink\" title=\"筹码稳定度\"></a>筹码稳定度</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"筹码稳定度\"><a href=\"#筹码稳定度\" class=\"headerlink\" title=\"筹码稳定度\"></a>筹码稳定度</h2>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjfqmxglc00001yoh9khu8iv2","tag_id":"cjfqmxglk00021yoh1honq5nu","_id":"cjfqmxgm0000b1yoh9at7p174"},{"post_id":"cjfqmxglc00001yoh9khu8iv2","tag_id":"cjfqmxgls00061yohe2rkg530","_id":"cjfqmxgm1000d1yohdeoqxg9q"},{"post_id":"cjfqmxglm00031yohcchtb4vk","tag_id":"cjfqmxglk00021yoh1honq5nu","_id":"cjfqmxgm9000j1yohq4ypewbs"},{"post_id":"cjfqmxglm00031yohcchtb4vk","tag_id":"cjfqmxgls00061yohe2rkg530","_id":"cjfqmxgma000l1yohjy7wizoi"},{"post_id":"cjfqmxglo00041yohtq6yvqjt","tag_id":"cjfqmxgm7000h1yoh4p3o001i","_id":"cjfqmxgmf000r1yohcuumnxfb"},{"post_id":"cjfqmxglo00041yohtq6yvqjt","tag_id":"cjfqmxgmb000m1yohncdqztbq","_id":"cjfqmxgmf000s1yoh07d428dv"},{"post_id":"cjfqmxglo00041yohtq6yvqjt","tag_id":"cjfqmxgme000p1yohabyh5poe","_id":"cjfqmxgmf000u1yohyp3xy4t5"},{"post_id":"cjfqmxglv00081yohg0hc1y07","tag_id":"cjfqmxgm7000h1yoh4p3o001i","_id":"cjfqmxgmg000w1yohtl8mifhl"},{"post_id":"cjfqmxglv00081yohg0hc1y07","tag_id":"cjfqmxgmf000t1yoh01x7s96y","_id":"cjfqmxgmg000x1yoh433uysxs"},{"post_id":"cjfqmxgly000a1yoh20ykef3u","tag_id":"cjfqmxgm7000h1yoh4p3o001i","_id":"cjfqmxgmh00111yoh5a29dgfe"},{"post_id":"cjfqmxgly000a1yoh20ykef3u","tag_id":"cjfqmxgmb000m1yohncdqztbq","_id":"cjfqmxgmh00121yoh5wwlpp4q"},{"post_id":"cjfqmxgly000a1yoh20ykef3u","tag_id":"cjfqmxgme000p1yohabyh5poe","_id":"cjfqmxgmi00141yohu1ongtc6"},{"post_id":"cjfqmxgm0000c1yohfy986iio","tag_id":"cjfqmxgm7000h1yoh4p3o001i","_id":"cjfqmxgmj00171yohrfi0ylox"},{"post_id":"cjfqmxgm0000c1yohfy986iio","tag_id":"cjfqmxgmb000m1yohncdqztbq","_id":"cjfqmxgmj00181yohwsnjecra"},{"post_id":"cjfqmxgm0000c1yohfy986iio","tag_id":"cjfqmxgme000p1yohabyh5poe","_id":"cjfqmxgmk001a1yoh6o1panv2"},{"post_id":"cjfqmxgm2000f1yohn7a3wqoy","tag_id":"cjfqmxgm7000h1yoh4p3o001i","_id":"cjfqmxgml001d1yoh8p31o6vl"},{"post_id":"cjfqmxgm2000f1yohn7a3wqoy","tag_id":"cjfqmxgmb000m1yohncdqztbq","_id":"cjfqmxgml001e1yohe1cp2ccb"},{"post_id":"cjfqmxgm2000f1yohn7a3wqoy","tag_id":"cjfqmxgme000p1yohabyh5poe","_id":"cjfqmxgmm001g1yoh5sj09ijm"},{"post_id":"cjfqmxgm6000g1yoh5j8xytnq","tag_id":"cjfqmxgmb000m1yohncdqztbq","_id":"cjfqmxgmm001h1yohz9l0ibwi"},{"post_id":"cjfqmxgm8000i1yoh2iircn4t","tag_id":"cjfqmxgm7000h1yoh4p3o001i","_id":"cjfqmxgmn001j1yoha96b47km"},{"post_id":"cjfqmxgm8000i1yoh2iircn4t","tag_id":"cjfqmxgmf000t1yoh01x7s96y","_id":"cjfqmxgmn001k1yoh335abgzf"},{"post_id":"cjfqmxgm9000k1yohwxffxlxd","tag_id":"cjfqmxgm7000h1yoh4p3o001i","_id":"cjfqmxgmo001n1yoh5bjkton5"},{"post_id":"cjfqmxgm9000k1yohwxffxlxd","tag_id":"cjfqmxgmb000m1yohncdqztbq","_id":"cjfqmxgmo001o1yohapnng0fl"},{"post_id":"cjfqmxgm9000k1yohwxffxlxd","tag_id":"cjfqmxgme000p1yohabyh5poe","_id":"cjfqmxgmo001p1yoh3k0cg748"},{"post_id":"cjfqmxgmd000o1yoh2nt2sn90","tag_id":"cjfqmxgmn001m1yohjuofg111","_id":"cjfqmxgmo001q1yohjp8v6wft"},{"post_id":"cjfqmxgli00011yohfxtok43g","tag_id":"cjfqmxglk00021yoh1honq5nu","_id":"cjfqmxyp6001t1yoh7i0az3v5"},{"post_id":"cjfqmxgli00011yohfxtok43g","tag_id":"cjfqmxgls00061yohe2rkg530","_id":"cjfqmxyp6001u1yohvo0437su"}],"Tag":[{"name":"产品","_id":"cjfqmxglk00021yoh1honq5nu"},{"name":"支付","_id":"cjfqmxgls00061yohe2rkg530"},{"name":"开发","_id":"cjfqmxgm7000h1yoh4p3o001i"},{"name":"后端","_id":"cjfqmxgmb000m1yohncdqztbq"},{"name":"python","_id":"cjfqmxgme000p1yohabyh5poe"},{"name":"前端","_id":"cjfqmxgmf000t1yoh01x7s96y"},{"name":"股票","_id":"cjfqmxgmn001m1yohjuofg111"}]}}